<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
-------------------------chapter4-------------------------
  <!-- 프로그래밍 기술을 이해하고 활용하기 위해서는 이 기술이 왜 만들어졌는지, 어떤 특징을 가졌는지 알 필요가 있습니다.
  따라서 이번 절에서는 리액트의 탄생 배경과 그 특징에 대해 좀 더 깊이 들여다 보겠습니다. 일정 정도는 설명 위주의 내용이지만, 리액트의 특징을 제대로 알아 두면 앞으로 진행할 예제 실습과 프로젝트 수행에 중요합니다.

  리액트의 탄생
  리액트는 복잡한 웹 서비스를 빠르게 개발할 수 있는 Node.js의 라이브러리 가운데 하나입니다.
  페이스북, 인스타그램, 넷플릭스 등 이름만 들어도 고개가 끄덕여지는 서비스를 개발한 기술이며, 지금도 전 세계 개발자들의 사랑을 듬뿍 받는 개발 도구입니다.

  리액트는 페이스북 개발팀이 만들어 2013년 오픈소스로 세상에 공개했습니다.
  출시 초키부터 페이스북은 동시대에 나온 웹 서비스 중 유독 인터렉션(Interaction)이 많았습니다.
  여기서 인터렉션은 상호작용, 소통 이라는 뜻으로, 좋아요 버튼이나 채팅처럼 사용자와 웹 서비스 간에 양방향으로 소통하는 기능을 지칭합니다.

  당시 대다수 기술은 정적인 웹을 구축하는데 초점을 두고 있엇기 때문에 페이스북이 원하는 다양한 인터렉션을 구현하기 힘들었습니다. 그래서 페이스북 개발팀은 서비스의 변화가 많고 사용자와 상호작용이 원활한 대규모 웹 애플리케이션을 쉡게 구축할 수 있는 기술이 필요했습니다. 그래서 이 기술을 직접 만들기로 하였고, 그 결과로 탄생한 것이 리액트입니다.
  
  리액트는 변화가 자주 일어나는 대규모 애플리케이션을 구축할 떄 필요한 여러 기능을 구비하고 있습니다. 이번 절에서는 이러한 리액트의 3가지 특징을 살펴보겠습니다.

  컴포넌트 기반의 유연성----------------------------
  리액트는 유연성이 있기 때문에 새로운 기능을 추가학거나 기능을 업그레이드할 때 코드를 많이 수정하지 않아도 됩니다.
  유연성이 없을 때 어떤 문제가 발생하는지 그리고 리액트가 채택한 컴포넌트 개념이 유연성 문제를 어떻게 해결하는지 살펴보겠습니다.
-->

<!-- 다음은 두 페이지로 구성한 아주 간단한 홈페이지입니다. -->

  <!-- index.html -->
  <!-- HEADER -->
  <header>
    <h1>안녕하세요</h1>
  </header>
  <article>
    <h3>여기는 Home 입니다.</h3>
  </article>

  <!-- about.html -->
  <header>
    <h1>안녕하세요</h1>
  </header>
  <article>
    <h3>여기는 about 입니다.</h3>
  </article>

  <!-- 
    index.html은 index 페이지, about.html은 about 페이지 입니다. 이 두 페이지의 구성은 매우 유사하며,
    <header> 태그는 내용이 완전히 똑같습니다.
    홈페이지에서 앞으로 추가할 페이지 또한 이 페이지들과 동일한 내용의 헤더 요소가 있다고 가정해 보겠습니다.
    예를 들어 other.html 페이지를 하나 더 추가해 보겠습니다.
   -->

   <!-- other.html -->
    <!-- HEADER -->
  <header>
   <h1>안녕하세요</h1>
  </header>
  <article>
    <!-- 페이지별로 필요한 요소를 작성 -->
  </article>

  <!-- 
    other.html 역시 똑같은 내용의 헤더 요소가 있습니다. 
    따라서 앞으로 새 페이지를 추가할 때 <header> 태그 요소는 기존 페이지의 소스 코드에서 복사하여 붙여 넣고,
    <article> 태그에서 해당 페이지에 필요한 요소만 새롭게 작성하면 됩니다.
    이 홈페이지의 <header> 태그 처럼 동일한 내용을 여러번 작성해야 하는 코드를 흔히 중복코드라고 합니다.
    코드의 중복은 유연성을 크게 해칩니다. 만약 이 홈페이지 <header> 태그에서 수정이 생기면, 모든 페이지에서 이 태그를 변경해야 하기 때문입니다.
    이런 식의 페이지 구성은 유연하지 못합니다. 페이지의 수가 많고, 기능 수정 또는 추가가 잦은 대규모 애플리케이션을 구축할 때는 적합하지 않습니다.

    컴포넌트 기반의 유연한 구조----------------------------
    리액트는 모듈화를 이용해 중복 코드를 제거합니다. 즉, 여러 페이지에서 공통으로 사용하는 코드를 컴포넌트 단위의 모듈로 만들어 놓고 필요할 때 호출해 사용합니다. 컴포넌트는 리액트를 대표하는 중요 개념 중 하나인데, 이 개념에는 페이지를 구성하는 요소라는 의미가 포함되어 있습니다.
    앞에서 문제의 원인이었던 <header> 태그를 컴포넌트로 만들면 다음과 같습니다.

    function MyHeader() {
      return (
        <header>
          <h1>안녕하세용</h1>
        </header>
      );
    }

    자바스크립트 함수 MyHeader는 <header> 태그를 반환합니다. 이렇게 HTML 요소를 반환하는 함수를 리액트에서는 컴포넌트라고 합니다.
    만약 <header> 태그가 필요한 페이지가 있다면 언제든지 이 컴포넌트를 불로와 사용하면됩니다.

      <!-- MyHeader.js에서 불러온 header 요소 -->
      <!-- <MyHeader />
      <article>
        <h3>여기는 Home 입니다.</h3>
      </article>

       -->
  <!-- 
    index.html 외에 다른 페이지에서도 이 컴포넌트를 불러와 위와 같은 방식으로 똑같이 사용할 수 있습니다.
    만약 header 컴포넌트에 변경 사항이 있어 코드를 수정하면, 일괄적으로 모든 페이지에 자동으로 반영되므로 기능 하나를 수정하기 위해 모든 페이지를 수정할 필요가 없습니다.

    컴포넌트를 더 자세히 이해하기 위해 리액트로 개발한 간단한 서비스를 살펴보겠습니다.
    상단에 헤더가 있고 중간에는 필터 그리고 여러개의 일기 아이템 컴포넌트가 있습니다.
    헤더는 현재 날짜를, 필터는 일기 아이템의 필터링을, 아이템 컴포넌트는 여러 개의 일기 정보를 각각 표시합니다.
    각각의 컴포넌트는 독립적인 기능을 수행하면서도 조화롭게 하나의 페이지를 구성하니다.

    리액트의 컴포넌트는 어떤 페이지에서도 불러올 수 있습니다. 예를 들어 A 페이지에서 헤더 컴포넌트가 필요하면 해당 페이지를 불러오면 되고,
    B 페이지에서 필요하면 똑같은 방식으로 불러와 사용하면됩니다.
    필요가 없어지면 삭제하면 그만 입니다. 이렇듯 리엑트에서는 컴포넌트를 마치 조립용 래고 블록처럼 다룰 수 있어 매우 유연하게 페이지를 구성합니다.

    쉽고 간단한 업데이트---------------------------
    업데이트란 웹 페이지의 정보를 교체하는 일입니다.
    업데이트의 좋은 예로 오늘날 대표적인 SNS로 자리 잡은 인스타그램의 좋아요 기능이 있습니다.

    인스타그램에서는 다른 사람이 올린 게시물에서 하트 모양 아이콘을 클릭해 좋아요를 표시할 수 있습니다. 
    좋아요 아이콘을 클릭하면 아이콘은 붉은 색으로 변합니다.
    웹에서 페이지를 업데이트하려면 문서 객체 모델(Document Object Model)DOM 을 조작해야 합니다.
    돔은 HTML 코드를 트리 형태로 변환한 구성물입니다. 돔은 웹 브라우저가 직접 생성하며, HTML 코드를 렌더링하기 위해 만듭니다.
    랜더링(Rendering)이란 브라우저가 웹의 3가지 언어 HTML,css, 자바스크립트를 해석해 페이지의 요소를 실제로 그려내는 과정입니다.
    
    자바스크립트로 돔을 조작하면 페이지를 새롭게 렌더링하여 업데이트합니다.

    그런데 돔에서 원하는 요소를 찾고 수정 사항을 변영하는 일은 언제나 간단하지 않습니다.
    돔은 트리 구조로 이루어져 있기 때문에, 구성이 복잡하면 정확히 원하는 요소를 찾기 어렵습니다.

    리액트는 이 문제를 아주 파격적인 방식으로 해결합니다. 사용자의 특정 행동(예를 들어 좋아요 버튼 클릭)이 일어나거나 
    데이터가 바뀌어 업데이트가 필요하면, 어떤 요소를 어떻게 업데이트할지 고민하지 않습니다. 교체가 필요한 요소는 삭제하고 
    새롭게 수정 사항을 반영한 요소를 다시 만들어 통째로 업데이트합니다.
    리액트의 이런 동작 방식은 마치 자동차가 고장 나면 일일이 망가지 부품을 찾아내 수리하기 보다 아예 새 차로 바꾸는 행위와 비슷합니다.

    따라서 리액트를 이용하면 어떤 부분을 어떻게 업데이트할지 고민하지 않아도 페이지를 업데이트할 수 있습니다.
    그래서 복잡한 인터랙션을 지원하는 웹 서비스 개발에 더 집중할 수 있습니다.

    빠른 업데이트----------------------------
    빠른 업데이트는 웹 서비스의 성능을 좌우하는 중요한 요소입니다. 만약 사용자가 버튼을 클릭할 때마다 페이지를 업데이트하는 데 5초이상 걸린다면 
    매우 짜증이 날 겁니다.
    리액트는 빠른 업데이트를 제공합니다. 이번에는 리액트가 빠르게 페이지를 업데이트하기 위해 어떤 기능을 지원하는지 살펴보겠습니다.

    브라우저는 어떻게 페이지를 표시할까?----------------------------
    업데이트는 결국 브라우저가 페이지를 다시 렌더링하는 행위입니다. 예를 들어 버튼을 클릭했을 때 버튼의 색상을 파란색에서 빨간색으로 바꾸려면 브라우저가 다시 렌더링해야 합니다. 따라서 리액트가 어떻게 빠르게 업데이트 하는지 알려면 브라우저의 렌더링 과정을 먼저 이해할 필요가 있습니다.
    브라우저의 렌더링 과정은 크게 4단계로 구분할 수 있습니다.

    1) HTML 코드를 해석해 돔으로 변환합니다. 마찬가지로 CSS 코드도 해석해 스타일 규칙(style rules)으로 변환합니다.
    2) 페이지의 어떤 요소가 있고 어디에 있는지를 아는 돔과 돔 각각의 요소에 스타일을 정의하는 스타일 규칙을 합쳐 렌더 트리를 만듭니다.
    3) 렌더 트리 정보를 바탕으로 요소의 위치를 픽셀 단위로 계산합니다. 이 과정을 레이아웃이라고 합니다. 레이아웃은 렌터링 과정에서 가장 많은 연산을 요구하는 과정입니다.
    4) 레이아웃 작업을 거치면 해당 정보를 바탕으로 요소를 실제로 페이지에 그립니다. 이 과정을 페이팅아라고 합니다. 페인팅 역시 레이아웃과 더불어
    렌더링 과정에서 가장 많은 연산을 요구하는 작업입니다.

    돔이 변경되면 브라우저는 업데이트를 위해 렌더링 과정을 다시 반복합니다.
    앞서 살펴본 렌더링 과정에서 요소의 위치를 결정하는 레이아웃과 요소를 실제로 페이지에 표시하는 페인팅 과정은 많은 연산을 동반합니다. 
    따라서 돔의 업데이트가 필요 이상으로 많아지면 브라우저의 성능을 떨어뜨리게 됩니다. 브라우저의 성능이 떨어지면 소위 랙 현상이 일어나거나
    심할 경우 응답 불능 상태에 빠집니다.

    버츄얼 돔을 이용한 효율적인 업데이트----------------------------
    페인팅과 레이아웃을 여러 번 수행하지 않으려면 여러 번의 업데이트를 모았다가 업데이트가 필요할 때 한 번에 처리하는 편이 효율적입니다.
    리액트는 이를 위해 버츄얼 돔을 활용합니다. 버추얼 돔은 가상의 돔이라는 뜻으로, 실제 돔의 사본입니다. 
    리액트에서는 페이지에서 변경 사항이 발생하면 먼저 버추얼 돔을 업데이트하는 식으로 변경 사항을 모았다가 한 번에 실제 돔을 업데이트합니다.\
    버추얼 돔을 3번 변경할 동안 실제 돔에는 아무런 변화가 없습니다. 변경 사항이 모두 종료되면, 변경 사항을 모았다가 한 번에 실제 돔을 업데이트합니다.
    결과적으로 리엑트에서는 여러 번의 업데이트를 모아 한 번에 수행하므로, 업데이트가 잦아도 브라우저의 성능을 떨어뜨리지 않습니다.

   -->

   <!--  리액트 앱 만들기 -->
   <!-- 
    이번 절에서는 리액트 앱을 직접 만들고 어떻게 사용하는지 알아보겠습니다. 
    리액트 앱은 리액트로 만든 웹 서비스입니다. 리액트 웹이 아닌 앱으로 부르는 까닭은 리액트로 만든 웹 서비스는 마치 애플리케이션처럼 
    다양하게 상호작용할 수 있는 기능을 제공하기 때문입니다.
    다시 말해 페이스북의 채팅 또는 좋아요 버튼 같은 서비스는 마치 사용자와 실시간으로 상호작용하는 응용 프로그램과 흡사히기 때문입니다.

    Create React App으로 리액트 앱 만들기
    리액트 앱은 처음 만들 때 꽤 복잡한 설정을 직접 해주어야 하니다.
    Node.js를 많이 사용해 본 사람에게는 쉬울 수 있지만 입문자에게는 꽤나 큰 장벅입니다. 따라서 이 책에서는 리액트 앱을 만들기 위해
    Create React App이라는 Node.js 라이브러리를 이용할 예정입니다.
    Create React App은 복잡한 설정 없이 리액트 앱을 만들어 주는 고마운 라이브러리 입니다.

    Create React App은 보일러 플레이트입니다.
    Create React App처럼 복잡한 설정 없이 쉽게 프로젝트를 생성하도록 돕는 개발 도구를 
    보일러 플레이트라고 합니댜. 보일러 플레이트란 보일러를 찍어내는 틀이라는 의미를 담고 있습니다.
    봉일러 플레이트를 이용하면 처음 보일러를 만들 때처럼 복잡한 구조를 염두에 두지 않고도 쉽게 보일러를 만들 수 있습니다.

    Create React App은 줄여서 CRA라고도 합니다. CRA는 리액트를 개발하고 운영하는 Meta가 직접 개발하고 운영하는 공식 보일러 플레이트입니다.

    리액트앱을 생성하기 위해 루트 폴더를 먼저 만들겠습니다. 문서 폴더 아래에 chapter4 폴더를 생성한 다음 비주얼 스튜디오 코드에서 이 폴더를 엽니다.
    
   루트 폴더를 만든다음 터미널에 아래의 명렁어를 입력합니다.
   npx create-react-app . // 점(.)은 현재 폴더를 의미합니다.
   이 코드는 현재 폴더에 새로운 리액트 앱을 만들라는 명령어입니다.

   npx는 무엇인가요?
   npx(Node Package Execute)는 노드 패키지 실행이라는 뜻의 명령어입니다.
   npx는 npm처럼 Node.js를 처음 설치할 때 함께 설치됩니다. npx를 이용하면 특정 라이브러리를 항상 최신 버전으로 실행할 수 있습니다.
   Create React App 같은 보일러 플레이트는 새로운 리액트 앱을 생성하려는 목적으로 사용하므로 
   특정 패키지에 설치해 두고 사용할 필요가 없습니다. 또 시간이 지나 업그레이드되면 새 버전이 npxjs.com에 출시됩니다.
   따라서 항상 최신 버전의 리액트 앱을 생성하기 위해서는 npx 명령을 이용해야 합니다.

   
   리액트 앱의 구성 요소 살펴보기----------------------------------------
   Create React App으로 리액트 앱을 만들었으므로 어떤 요소가 생성되었는지 살펴보겠습니다.
   비주얼 스튜디오 코드에서 chapter4를 클릭하면 새롭게 생성한 리액트 앱의 구성 요소들을 살펴볼 수 있습니다.

   Create React App으로 생성한 리액트 앱 또한 Node.js 패키지입니다. 따라서 이 루트 폴더 아래에는 
   package.json, package-lock.json, node_modules 같은 Node.js 패키지 구성 파일이 존재합니다.
   그런데 3장에서 살펴본 외부 라이브러리를 설치하는 폴더 node_modules 외에도 public.src와 같은 폴더도 보입니다.
   이 폴더는 Create React App이 자동으로 생성한 폴더들입니다.
   Create React App은 리액트 앱을 생성함과 동시에 앱이 동작하는 데 필요한 파일과 폴더를 자동으로 생성합니다.
   이런 파일과 폴더 모음을 다른 말로 템플릿이라고 합니다.

   그럼 Create React App이 자동으로 생성한 탬플릿 파일과 폴더를 대략 살펴보겠습니다.
   package.json 에서 dependencies 항목을 보면 Create React App으로 생성한 리액트 앱에는 어떤 라이브러리가 설치되는지,
   리액트 버전은 몇 버전인지 등에 대한 정보를 알 수 있습니다.

   public 폴더는 리액트에서 공통으로 사용하는 폰트 파일, 이미지 파일 등을 저장하는 폴더입니다.
   favicon.ico, index.html, logo192.png, logo512.png, manifest.json, robots.txt 등의 파일들이 기본으로 포함되어 있습니다.

   src 폴더는 소스(soruce) 폴더라는 뜻으로 프로그래밍 소스를 저장하는 폴더입니다.
   이 폴더는 리액트를 사용하는 동안 자바스크립트 파일들을 한데 모아놓은 곳으로, 프로젝트에서 사용할 소스 파일을 저장합니다.


   리액트 앱 실행하기 ----------------------------------------
   명령어를 이용해 리액트 앱을 실행하고 종료하겠습니다. 리액트 앱을 실행하는 명령어는 package.json의 script에 작성되어 있습니다.
   package.json의 script에는 start 명령으로 리액트 앱을 실행하는 스크립트가 있습니다.
   
   npm run start

   이 스크립트를 실행하면 리액트 앱을 실행합니다.
   자동으로 크롭 웹 브라우저에서 새 탭이 열리면서 리액트 앱의 주소인 http://localhost:3000에 접속합니다.

   리액트 앱의 동작 원리----------------------------------------
   지금까지 리액트 앱을 생성하고 어떤 요소가 있는지 확인하고 실행까지 해보았습니다.
   이번 절에서는 리액트 앱이 어떻게 동작하는지 그 원리를 좀 더 자세히 살펴보겠습니다.

   리액트 앱에는 어떻게 접속하는 걸까?----------------------------------------
   앞서 create-react-app 명령으로 리액트 앱을 만들고 npm run start 명령으로 앱을 구동해 보았습니다.
   그 결과 리액트 앱을 실행하면 http://localhost3000으로 접속한다는 사실을 알게 되었습니다.
   
   그렇다면 어떤 원리로 리액트 앱에 접속하는 걸까요? 결론부터 말하자면 Create React App으로 만든 리액트 앱에는 웹 서버가 내장되어 있습니다.
   즉, npm run start 명령을 실행하면 브라우저가 리액트 앱에 접속하도록 앱에 내장된 웹 서버가 동작합니다.
   결국 내장된 웹 서버 주소로 브라우저가 자동으로 접속합니다.
   --------------------------------------------------------------------------------------------------------------
   웹 서버는 브라우저의 요청에 따라 필요한 웹 페이지를 보내주는 컴퓨터입니다.
   예를 들어 웹 서버는 사람들이 접속할 수 있는 http://naver.com 이라는 주소를 갖고 있습니다.
   해당 주소로 접속 요청이 들어오면 웹 서버에서 네이버의 웹 페이지를 보내줍니다.
   --------------------------------------------------------------------------------------------------------------
   네이버 웹 서버에 접속하려면 https://naver.com 이라는 주소를 입력하듯이 웹 서버에는 자신만의 주소가 있습니다.
   Create React App으로 생성한 리액트 앱의 주소는 기본적으로 http://localhost:3000으로 설정되어 있습니다.
   그러므로 이 주소로 요청해야 앞에서 생성한 리액트 앱에 접속할 수 있습니다.

   그렇다면 localhost:3000이라는 주소는 어떤 의미일까요? 먼저 localhost는 내 컴퓨터의 주소를 가리킵니다.
   따라서 localhost 주소로 무언가를 요청하면, 해당 요청은 여러분의 컴퓨터에 전달됩니다.
   이것은 마치 우체국에 가서 여러분의 집 주소로 편지를 보내는 것과 같은 원리입니다.

   localhost 뒤에 콜론(:)과 함계 나오는 3000은 포트 번호입니다. 
   포트 번호는 컴퓨터에서 실행되고 있는 서버를 구분하는 번호입니다.
   컴퓨터에는 기본적으로 하나의 주소가 있는데, 이 주소로 요청을 받습니다. 그런데 컴퓨터에 여러 개의 서버가 실행되고 있다면,
   요청을 받았을 때 어떤 서버에 대한 요청인지 모호할 수 있습니다. 따라서 서버별로 포트 번호를 정해놓으면, 해당 포트 번호에 대한 요청이
   들어올 때만 응답하는 식으로 작업을 선별해 처리할 수 있습니다.
   Create React Appp으로 만든 리액트 앱의 기본 포트 번호는 3000번입니다. 따라서 http://localhost:3000과 같이 
   localhost 3000번 포트의 서버로 접속을 요청해야 정상적으로 리액트 앱에 접속할 수 있습니다.


   리액트 앱의 동작원리 상세보기----------------------------------------
   리액트 앱을 실행하고 http://localhost:3000 주소로 접속하면 움직이는 리액트 로고 페이지가 나옵니다.
   이 페이지 하단에는 Edit src/App.js and save to reload라는 문장이 있는데, src 폴더의 App.js를 수정하고 저장하여 다시 로드하라는 뜻입니다.

   src 폴더의 App.js의 App 함수의 return 을 아래와 같이 바꾸면 페이지의 렌더링 결과가 달라집니다.
   function App() {
    return (
    <div className="App">
      <h2>안녕하세요</h2>
    </div>
    );
  }

  함수 App 처럼 HTML을 반환하는 자바스크립트 함수를 컴포넌트라고 했습니다.
  컴포넌트는 이름과 함께 부르기 때문에 이제부터 App 컴포넌트라고 하겠습니다.

  이처럼 페이지의 랜덩링 결과가 달라진 이유는 무엇일까요?
  이를 이해하려면 리액트 앱이 어떻게 동작하는지 알 필요가 있습니다.

  사용자가 주소 http://localhost:3000으로 리액트 앱에 대한 서비스를 요청하면, 리액트 엡 서버에서는 
  우선 웹 페이지 파일인 public 폴더의 index.html을 보냅니다.
  일반적으로 특정 웹 서비스에 접속하면 처음 만나는 페이지는 대체로 index.html 파일입니다.
  따라서 index.html을 열어 보면 왜 이런 결과가 나오는지 알 수 있습니다.
  index.html을 열어 실제 페이지를 브라우저에 표시하는 <body> 태그를 확인하겠습니다.
  
  그러나 index.html의 <body> 테그에는 브라우저가 자바스크립트를 실행할 수 없을 때만
  나타나는 <noscript> 태그와 id가 root인 빈 <div> 태그밖에 없습니다.
  따라서 index.html에는 페이지에 표시할 만한 요소가 하나도 없습니다.

  뭔가 이상합니다. 분명 index.html에는 페이지에 표시할 만한 요소가 하나도 없는데,
  http://localhost:3000으로 리액트 앱에 접속하면 App 컴포넌트에서 수정했던 
  내용을 페이지가 표시하기 때문입니다.

  이를 이해하려면 개발자 도구 요소탭에 head 태그에 작성된 
  <script defer src=".../bundle.js> 태그를 확인해야 합니다.
  <script>는 리액트 앱에 접속하면 자동으로 index.html에 추가되는 태그입니다.
  <script> 태그는 /static/js 경로에 있는 bundle.js라는 자바스크립트 파일을 불러와 실행합니다.

  ---------------------------
  bundle은 꾸러미, 묶음이라는 뜻입니다. 
  bundle.js는 src 폴더에 있는 자바스크립트 파일을 한데 묶어 놓은 파일입니다. 이렇게 여러 자바스크립트 파일을 하나로 묶는 작업을 번들링이라고 하며, 그 결과물인 bundle.js를 번들 파일이라고 합니다.
  ---------------------------

  bundle.js는 src 폴더에 있는 index.js와 이 파일이 불러온 모듈을 하나로 묶어 놓은 파일입니다.
  결국 이 번들 파일은 index.js가 작성한 코드에 따라 동작합니다. 따라서 index.js에 어떤 내용이 있는지 살펴봐야 리액트 앱의 동작을 제대로 이해할 수 있습니다.

  src 폴더에 있는 index.js에는 다음과 같은 코드가 작성되어 있습니다.

---------------------------------------------------------------
  import React from 'react';
  import ReactDOM from 'react-dom/client';
  import './index.css';
  import App from './App';
  import reportWebvitals from './reportWebvitals';

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(
    <React.StrickMode>
      <App />
    </React.StrickMode>
  );

  // if you want to start measuring performance in your app,
  pass a function
  // to log results(for example: reportWebVitals(console.log))
  // or send to an analystic endpoint. Learn more: https://bit.ly/CRA-vitals
  reportWebVitals();

  ---------------------------------------------------------------

  index.js 파일에는 17줄의 코드가 작성되어 있습니다.
  구체적으로 살펴보겠습니다.
  먼저 살펴볼 것은 import 문입니다.

  import App from './App';

  index.js에서는 import 문으로 App.js에 있는 App 컴포넌트를 포함해 여러 개의 모듈을 불러옵니다.
  다음으로 살펴볼 부분은 ReactDOM.createRoot 메서드입니다.

  ReactDOM.createRoot는 인수로 전달한 요소를 리액트 앱의 루트로 만들어 반환하는 매서드 입니다.
  여기서 루트란 뿌리라는 뜻이며, 트리 형태의 톰에서 자바스크립트 함수로 작성한
  컴포넌트들의 루트 요소를 가리킵니다.

  ReactDOM.createRoot 매서드에 인수로 document.getElementById('root')를 전달하는데, 이 메서드는 돔에서 id가 'root'인 요소를 찾아 반환합니다.

  이 코드의 의미를 다시 정리하면 돔에서 id가 'root'인 요소를 루트로 만들어 
  root라는 변수에 저장합니다. id가 root인 요소는 이미 앞에서 살펴보았습니다.
  바로 public 폴더의 index.html에 있는 <div> 태그가 바로 루트 요소입니다.

  계속해서 다음으로 살펴볼 부분은 ReactDOM.createRoot 메서드 바로 아래에 위치한
  root.render 메서드입니다.

  -----------------------------------------------------------------
  root.rander(
    <React.StrickMode>
      <App />
    </React.StrickMode>
  );
  -----------------------------------------------------------------
  변수 root에는 현재 리액트의 루트가 저장되어 있습니다.
  render 메서드는 인수로 리액트 컴포넌트를 전달하는데, 이 컴포넌트를 돔 루트에 추가합니다.
  따라서 render 메서드가 수행되면 전달된 리액트 컴포넌트가 돔에 추가되어 페이지에 나타납니다.
  결론적으로 이 코드는 App 컴포넌트를 돔 루트에 추가하므로, 페이지에 App 컴포넌트에서 정의한 HTML 요소가 표시됩니다.

  http://localhost:3000에서 개발자 도구를 열고,
  요소 탭에서 리액트의 루트 요소로 <div id='root'> 를 클릭하면,
  해당 요소 아래에 App 컴포넌트가 반환하는 HTML 요소가 추가되어 있음을 확인할 수 있습니다.


  지금까지 리액트 앱의 동작 원리를 살펴보았습니다. 리액트 애의 동작 방식을 다시 
  한번 정리하면 다음과 같습니다.

  1. localhost:3000으로 접속을 요청하면 public 폴더의 index.html을 반환합니다.
  
  2. index.html은 src 폴더의 index.js와 해당 파일이 가져오는 자바스크립트 파일을 한데 묶어 놓은 bundle.js를 불러옵니다. <script> 태그에서 자동으로 추가합니다.
  
  3. bundle.js가 실행되어 index.js에서 작성한 코드가 실행됩니다.

  4. index.js는 ReactDOM.createRoot 메서드로 돔에서 리액트 앱의 루트가 될 요소를 지정합니다.

  5. render 메서드를 사용해 돔의 루트 아래에 자식 컴포넌트를 추가합니다. 결과적으로 App 컴포넌트가 렌더링됩니다.

  약간 복잡해 보이지만 리액트 앱의 기본 원리와 동작을 차근차근 살펴보았습니다.
  지금은 모든 내용을 완전히 이해하지 못하더라도 큰 문제는 없습니다. 앞으로 진행 할 예제들과 프로젝트를 구현하면서 리액트 앱의 동작 원리가 다시 궁금해지면 다시 한번
  4장으로 돌아와 살펴보길 바랍니다.

  리액트 앱의 기본 원리 그리고 동작 방식을 잘 몰라도 몇 가지 예제 정도만 배우면
  간단한 리액트 앱을 만들 수 있습니다.
  입문자 입장에서는 그런 방식이 더 빠르게 결과물을 만들어 볼 수 있으니 효율적이라고 생각할 수도 있습니다.
  그러나 실력있는 프론트앤드 개발자로 성장하려면 언제나 기초가 중요합니다.
  실무에서는 상상하기 힘들 정도로 복잡한 리액틍 앱을 직접 다뤄야 합니다.
  이때 동작 원리를 제대로 이해하고 있지 못한다면 다양한 상황에 효율적으로 대처하기 어렵습니다. 또 새로운 기능이 공개되거나 추가되었을 때에도 학습 속도가 상대적으로 더디게 될 겁니다.


  -----------------------------------------------------------------
  -----------------------------------------------------------------
  -----------------------------------------------------------------
  -------------------------chapter5--------------------------------
  컴포넌트------------------------------
  개발자들은 리액트를 컴포넌트 기반의 UI 라이브러리라고 소개합니다.
  페이지의 모든 요소를 컴포넌트 단위로 쪼개어 개발하고, 완성된 컴포넌트를 마치 레고 조립하듯이 하나로 합쳐 페이지를 구성하기 때문입니다. 리액트로 웹 서비스를 개발할 때는
  컴포넌트를 여러 개 만들어 이를 적절히 조합해서 만들곤 합니다.
  이번 절에서는 리액트의 핵심 개념 중 하나인 컴포넌트를 자세히 살펴보겠습니다.

  실습 환경 설정하기------------------------------
  5장에서 사용할 새 리액트 앱을 만들겠습니다.

  리액트 앱 만들기------------------------------
  문서 아래에 chapter5 폴더를 만든다.
  npx create-react-app를 입력해서 새로운 리액트 앱을 만든다.

  사용하지 않는 파일 삭제하기------------------------------
  혼동을 피학고자 src 폴더에서 실습에 사용하지 않을 파일 일부를 제거헙니다. 다음 파일을 제거합니다.
  src/App.text/js
  src/logo.svg
  src/reportWebVitals.js
  src/setupTest.js
  이 파일들은 Create React App이 자동으로 생성한 파일들로 테스트 코드를 작성하거나 리액트 앱의 성능을 살필때 사용합니다.
  진행할 실습에서는 사용하지 않으므로 삭제합니다.

  사용하지 않을 코드 삭제하기------------------------------
  이번에는 create react app이 자동으로 생성하지만, 실습에서 사용하지 않은 코드를 모두 삭제합니다.
  다음과 같이 src 폴더의 index.js에서 주석//으로 표시한 코드는 모두 삭제합니다.

  ---------------------------------------------------------------
  ---------------------------------------------------------------
  import React from 'react';
  import ReactDOM from 'react-dom/client';
  import './index.css';
  import App from './App';
  // import reportWebvitals from './reportWebvitals'; (1)

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(
  //  <React.StrickMode> (2)
      <App />
  //  </React.StrickMode> (3)
  );

  // if you want to start measuring performance in your app,
  pass a function
  // to log results(for example: reportWebVitals(console.log))
  // or send to an analystic endpoint. Learn more: https://bit.ly/CRA-vitals
  // reportWebVitals(); (4)
  ---------------------------------------------------------------
  ---------------------------------------------------------------

  (1) reportWebVitals.js 는 앞서 삭제한 파일 가운데 하나입니다. 이 파일을 불러오는 import 문을 삭제합니다.
  reportWebVitals는 리액트 앱의 성능 측정 용도로 사용하는 파일입니다.

  (2) React.StrickMode는 리액트 앱 내부의 잠재적인 문제를 검사하는 도구입니다.
  프로그래머가 예상하지 못한 코드상의 부작용을 탐지하거나 구버전 리액트 기능을 사용하는지 등을 살핍니다.
  이 설정이 있으면 리액트 입문자에게 혼란을 줄 수 있어 제거합니다.
  (3)(4)동일한 이유로 삭제

  ---------------------------------------------------------------
  ---------------------------------------------------------------
  import React from 'react';
  import ReactDOM from 'react-dom/client';
  import './index.css';
  import App from './App.js';

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
  ---------------------------------------------------------------
  ---------------------------------------------------------------

  다음으로 src 폴더의 App.js에서 사용하지 않을 코드를 삭제합니다.


  ---------------------------------------------------------------
  ---------------------------------------------------------------
  import logo from './logo.svg';
  import './App.css';

  function App() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <p>
            Edit <code>src/App.js</code> and save to reload.
          </p>
          <a
            className="App-link"
            href="https://reactjs.org"
            target="_blank"
            rel="noopener noreferrer"
          >
            Learn React
          </a>
        </header>
      </div>
    );
  }

  export default App;
  ---------------------------------------------------------------
  ---------------------------------------------------------------

  ---------------------------------------------------------------
  ---------------------------------------------------------------
  import './App.css';

  function App() {
    return <div className='App'></div>;   // (1)
  }
  export default App;
  ---------------------------------------------------------------
  ---------------------------------------------------------------
  (1) <div className='App'>을 삭제하면 오류가 발생합니다.. JSX 문법을 위반하기 때문입니다.

  불필요한 파일과 코드를 모두 제거했다면, 터미널에서 npm run start 명령으로 리액트 앱을 시작합니다.
  App.js의 내용을 대부분 삭제했으므로 빈 페이지가 나옵니다.

  첫 컴포넌트 만들기------------------------------------
  리액트 컴포넌트는 주로 자바스크립트의 클래스나 함수를 이용해 만듭니다.
  클래스로 컴포넌트를 만드는 방식은 기본 설정 코드를 작성하는 등 함수로 만드는 컴포넌트에 비해 단점이 많아 지금은 선호하지 않습니다.
  리액트 공식 문서에서도 클래스보다는 함수로 컴포넌트를 만드는 것을 권장하고 있습니다.

  함수 컴포넌트 만들기--------------------------------
  함수를 이용해 App.js에서 첫 번째 컴포넌트를 만들겠습니다. App.js를 다음과 같이 수정합니다.

  ---------------------------------------------------------------
  ---------------------------------------------------------------
  import './App.css';

  function Header() {     // (1)
    return (
      <header>
        <h1>header</h1>
      </header>
    );   // (2)
  }

  function App() {
    return (
      <div className='App'></div>;
    )
  }
  export default App;
  ---------------------------------------------------------------
  ---------------------------------------------------------------
  (1) 함수를 이용해 Header라는 이름의 컴포넌트를 App 컴포넌트 밖에서 만듭니다.
  (2) Header 컴포넌트는 HTML을 반환합니다. 여러 줄로 이루어진 HTML을 반환할 때는 return 문에서
  변환할 HTML을 소괄호로 감싼 다음에 세미콜론을 꼭 붙여 주어야 합니다.

  페이지에서 헤더 역할을 담당할 Header 컴포넌트를 만들었습니다.
  이렇듯 함수를 이용하면 매우 간단하게 리액트 컴포넌트를 만들 수 있습니다.
  즉, 함수를 선언하고 해당 함수가 HTML 요소를 반환하도록 만들면 됩니다.
  함수를 사용해 만든 컴포넌트를 특별히 함수 컴포넌트라고 합니다.

  현재 Header 컴포넌트는 페이지에 랜더링하는 아무런 설정도 하지 않았기 때문에
  저장해도 빈 페이지만 표시할 뿐입니다.

  참고로 함수 선언식이 아니라 화살표 함수로도 컴포넌트를 만들 수 있습니다.

  ---------------------------------------------------------------
  App.js
  ---------------------------------------------------------------
  import './App.css';

  const Header = () => {  // (1)
    return (
      <header>
        <h1>header</h1>
      </header>
    )
  }

  function App() {
    return <div className='App'></div>;
  }
  export default App;
  ---------------------------------------------------------------
  ---------------------------------------------------------------
  (1) 화살표 함수를 이용해 header 컴포넌트를 만듭니다.

  컴포넌트의 이름은 항상 대문자로 시작하기
  함수 컴포넌트를 만들 때 한 가지 주의할 점이 있습니다. 컴포넌트 함수 이름의 첫 글자는 항상 영어 대문자여야 합니다.
  그 이유는 리액트 컴포넌트를 HTML 태그와 구분하기 위해서입니다.

  컴포넌트를 페이지에 랜더링하기---------------------------------------------
  Header 컴포넌트를 페이지에 랜더링하려면 App에서 이 컴포넌트를 자식 요소로 배치해야 합니다.
  App 컴포넌트를 다음과 같이 수정합니다.
  리액트는 다른 컴포넌트를 태그로 감싸 사용합니다. 이때 App처럼 다른 컴포넌트를 return 문 내부에 포함하는 컴포넌트를 부모 컴포넌트라고 합니다.
  반대로 Header 처럼 App의 return 문에 포함된 컴포넌트를 자식 컴포넌트라고 합니다.
  이렇게 부모의 return 문에 자식을 포함하는 행위를 자식 컴포넌트를 배치한다라고 표현합니다.

  Header를 App의 자식 컴포넌트로 배치했다면, 저장하고 페이지에서 어떤 변화가 있는지 확인합니다.

  Header 컴포넌트를 페이지에 랜더링했습니다.

  컴포넌트의 계층 구조========================================================
  앞서 App에서 Header 컴포넌트를 자식으로 배치했더니 페이지에서 Header를 렌더링했습니다. 왜 그런 걸까요?
  그 이유는 리액트가 컴포넌트를 페이지에 랜더링하는 과정을 되짚어 보면 쉽게 이해할 수 있습니다.
  4장에서 Create React App으로 생성한 리액트 앱의 구성을 배우면서 index.js를 잠시 살펴본적이있습니다.
  index.js에서는 App 컴포넌트를 리액트의 루트 요소 아래에 배치에 랜더링한다고 했습니다.
  기억을 되살리는 의미에서 index.js 파일을 다시 클릭합니다.

  index.js
  ====================================================================================
  import React from 'react';
  import ReactDOM from 'react-dom/client';
  import './index.css';
  import App from './App';

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
  ====================================================================================

  index.js를 보면 페이지에 랜더링하는 컴포넌트는 App 하나뿐입니다.
  따라서 새로운 컴포넌트를 페이지에 랜더링하려면 이 컴포넌트를 App의 자식으로 배치해야 합니다.
  단지 컴포넌트를 생성한다고 해서 바로 페이지에 렌더링하지는 않습니다.
  리액트에서 부모는 자식 컴포넌트의 모든 HTML을 함꼐 반환합니다. 예컨대 chapter5 앱이라면
  App는 Header 컴포넌트의 HTML도 함께 반환합니다. 
  따라서 Header를 자식으로 배치한 App 컴포넌트의 예는 HTML로 작성한 다음 코드와 의미상으로 동일합니다.

  App.js
  ====================================================================================
  import './App.css';

  function App() {
    return (
      <div className="App">
        <Header>
          <h1>Header</h1>
        </Header>
      </div>
    );
  }
  export default App;
  ====================================================================================
  
  리액트는 자식으로 배치한 컴포넌트를 부모와 함께 렌더링합니다.
  만약 페이지에 렌더링할 컴포넌트가 3개가 필요하다면, 각각을 컴포넌트로 만든다음 App의 자식으로 배치해야합니다.

  리액트에서 컴포넌트를 페이지에 랜더링하려면, App의 자식으로 배치하거나 Header처럼 자식으로 이미 배치된 컴포넌트의 또 다른 자식으로 배치해야 합니다.
  리액트 컴포넌트는 부모-자식 관계라는 계층 구조를 형성합니다. 컴포넌트의 계층 구조를 다른 말로 컴포넌트 트리라고 합니다.
  그리고 컴포넌트 트리에서 App는 항상 최상위에 존재하므로 이를 루트 컴포넌트라고 부릅니다.

  컴포넌트별로 파일 분리하기======================================================================
  리액트에서는 보통 하나의 파일에 하나의 컴포넌트를 만듭니다. 이유는 하나의 파일에 여러 컴포넌트를 만들면 가독성이 떨어지기 때문입니다.
  
  이번에는 컴포넌트를 여러 파일로 나누고, App.js에서 불러와 App 컴포넌트의 자식으로 배치하겠습니다.
  그 전에 컴포넌트 파일만 따로 모아 보관할 폴더를 하나 만들겠습니다.

  리액트 앱 chapter5의 src에 component라는 이름으로 폴더를 만듭니다.
  계속해서 이 폴더에 Header 컴포넌트를 담당할 Header.js를 생성합니다.


  src/component/Header.js
  ====================================================================================
  function Header() {
  return (
    <header>
      <h1>Header</h1>
    </header>
    );
  }

  export default Header; // (1)
  ====================================================================================
  (1) Header 컴포넌트를 다른 파일에서 사용할 수 있도록 내보냅니다. 이때 원하는 이름으로 불러올 수 있도록
  모듈의 기본값으로 내보냅니다.

  App.js에서 App 컴포넌트 바깥에 만들었던 Header 코드는 모두 삭제합니다.

  src/App.js
  ====================================================================================
  import './App.css';

  function App() {
    return (
      <div className="App">
        <Header />
      </div>
    );
  }

  export default App;
  ====================================================================================

  Header 컴포넌트를 삭제하고 저장하면 오류가 발생합니다.
  이는 App 컴포넌트의 자식으로 배치한 Header를 찾을 수 없기 떄문입니다.

  오류가 발생한 이유는 Header 컴포넌트가 App.js에 선언되어 있지 않고,
  다른 파일에서 불러오지도 않기 때문입니다. 리액트에서 선언되지 않은 컴포넌트를 사용할 때,
  "컴포넌트 이름) is not defined" 와 같은 오류가 발생합니다.

  오류를 해결하려면 App.js 에서 Header 컴포넌트를 불러와야 합니다.


  ================v================================================================================
  import './App.css';
  import Header from './component/Header'; (1)

  function App() {
    return (
      <div className="App">
        <Header />
      </div>
    );
  }

  export default App;
  ================================================================================================
  
  다음으로 페이지의 몸통 역할을 수행할 Body와 페이지 정보를 표시할 Footer 컴포넌트를 만들겠습니다.
  component 폴더에 Body.js와 Footer.js를 각각 만들고 다음과 같이 코드를 작성합니다.

  ./component/Body.js
  ================================================================================================
  function Body() {
  return (
    <div>
      <h1>body</h1>
    </div>
    );
  }
  export default Body;
  ================================================================================================

  ./component/Footer.js
  ================================================================================================
  function footer() {
  return (
    <footer>
      <h1>footer</h1>
    </footer>
    );
  }
  export default footer;
  ================================================================================================

  이제 component 폴더에는 Header.js, Body.js, Footer.js 3개의 파일이 존재합니다.
  Body와 Footer를 페이지에 랜더링하려면 App.js에서 두 컴포넌트를 불러와 App의 자식으로 배치해야 합니다.


  App.js
  ================================================================================================
  import './App.css';
  import Header from './component/Header';
  import Body from './component/Body';
  import Footer from './component/Footer';

  function App() {
    return (
      <div className="App">
        <Header />
        <Body />
        <Footer />
      </div>
    );
  }

  export default App;
  ================================================================================================

  파일을 저장하고 페이지에서 Header, Body, Footer 컴포넌트를 잘 렌더링하는지 확인합니다.
  3개의 컴포넌트를 잘 랜더링하고 있습니다.

  JSX===========================================================================================================
  지금까지 리액트의 핵심이라고 할 수 있는 컴포넌트의 개념을 살펴보았고, 첫 번째 컴포넌트도 만들었습니다.
  이번 절에서는 컴포넌트를 만들 때 사용하는 JSX 문법을 자세히 살펴보겠습니다.

  JSX란?================================================================================================
  리액트에서 컴포넌트는 자바스크립트 함수로 만드는데, 특이하게도 이 함수는 HTML 값을 반환합니다.
  이렇듯 자바스크립트와 HTML 태그를 섞어 사용하는 문법을 JSX(자바스크립트 XML)라고 합니다.
  JSX는 자바스크립트의 확장 문법입니다.

  JSX는 공식 자바스크립트 문법은 아닙니다.
  그러나 JSX는 대사수 리액트 개발자가 사용하는 문법이며, 리액트 공식 문서의 예제로도 사용합니다.
  심지어 리액트 개발팀 또한 JSX 문법의 사용을 적극 권장하고 있습니다.
  
  JSX 문법을 이용하면 HTML 태그에서 자바스크립트의 표현식을 직접 사용할 수 있습니다.
  비주얼 스튜디오 코드에서 component 폴더의 Body.js를 다음과 같이 수정합니다.


  Body.js
  ====================================================================================
  function Body() {
  const number = 1;  // (1)
  return (
    <div>
      <h1>body</h1>
      <h2>{number}</h2>  // (2)
    </div>
    );
  }
  export default Body;
  ====================================================================================
  (1) 상수 number를 선언하고 값1을 저장합니다.
  (2) 상수 number의 값을 <h2>태그로 감싸 렌더링합니다. 이때 상수 number가 자바스크립트 표현식이라는 걸 표현하기 위해 중괄호{}를 사용합니다.

  Body.js를 수정했다면 저장하고 페이지에서 상수 number 값을 잘 렌더링하는지 확인합니다.
  상수 number에 저장한 값1을 잘 렌더링하고 있습니다.

  
  JSX와 자바스크립트 표현식======================================================================
  표현식이란 값으로 평가되는 식입니다.
  즉, 10 + 20 같은 식은 결국 30으로 평가되기 때문에 표현식이라고 합니다. 
  JSX는 자바스크립트 표현식을 HTML 태그와 함꼐 사용할 수 있어 가독성 있는 코드를 작성할 수 있습니다.

  그럼 JSX에서 자주 사용하는 표현식을 하나씩 살펴보겠습니다.

  산술 표현식====================================================================================
  산술 표현식이란 숫자로 표현되는 식을 말한니다. component 폴더의 Body.js를 다음과 같이 수정합니다.

  
  Body.js
  ====================================================================================
  function Body() {
  const numA = 1;
  const numB = 2;
  return (
    <div>
      <h1>body</h1>
      <h2>{numA + numB}</h2> (1)
    </div>
    );
  }
  export default Body;
  ====================================================================================
  (1) numA + numB는 두 변수를 더한 연산자입니다. 이 연산식은 숫자로 평가되는 산술 표현식이므로 JSX 문법과 함께 사용합니다.


  문자열 표현식====================================================================================
  문자열 표현식이란 문자열 또는 문자열로 평가되는 식을 말합니다. component 폴더의 Body.js를 다음과 같이 수정합니다.


  Body.js====================================================================================
  function Body() {
  const strA = '안녕';
  const strB = '리액트';
  return (
    <div>
      <h1>body</h1>
      <h2>{`${strA}${strB}`}</h2> 
      <h2>{strA + strB}</h2>
      <h2>hello world</h2>
    </div>
    );
  }
  export default Body;
  ====================================================================================


  논리 표현식================================================================================
  논리 표현식이란 참이나 거짓으로 평가되는 식입니다.component 폴더의 Body.js 를 다음과 같이 수정합니다.

  사용할 수 없는 값ㅍ======================================================================
  JSX는 값을 반환하는 자바스크립트 표현식을 사용할 수 있습니다.
  그러나 모든 값을 사용할 수 있는 것은 아닙니다. 원시 자료형에 해당하는 숫자, 문자열, 불리언, null, undefined를 제외한
  값을 사용하면 오류가 발생합니다.
  Body 컴포넌트에서 객체 자료형을 JSX 문법으로 사용해 보겠습니다. component 폴더의 Body.js를 다음과 같이 수정합니다.


  Body.js
  ========================================================================================
  function Body() {
  const objA = {
    a:1,
    b:2,
  };
  return (
    <div>
      <h1>body</h1>
      <h2>{objA}</h2>
    </div>
  );
}

export default Body;
========================================================================================

객체 자료형 값을 반환하는 표현식을 JSX 문법으로 작성한 다음, 저장하면 페이지에는 아무것도 나타나지 않습니다.
개발자 도구의 콘솔을 열어보면 오류가 발생했다는 것을 알 수 있습니다.

Uncaught Error: Objects are not valid as a React child

콘솔의 내용을 살펴보면 Object are not valid a React Child 라는 메시지를 발견할 수 있는데,
객체는 리액트의 자식으로 유효하지 않다 라는 뜻입니다.
결론을 말하면 JSX에서는 객체 자료형을 지원하지 않습니다. 객체 자료형에 속하는 함수나 배열도 
JSX 표현식으로 사용하면 오류가 발생합니다.
만약 객체 자료형의 값을 페이지에 랜더링하고 싶다면, 포로퍼티 접근 표기법으로 값을 원시 자료형으로 바꿔 주어야 합니다.



========================================================
      <h2>{objA.a}</h2>
      <h2>{objA.b}</h2>
========================================================

JSX 문법에서 지켜야 할 것들==========================================
JSX를 사용해 리액트 컴포넌트를 생성할 떄 반드시 지켜야 할 문법들이 있습니다.
이 문법 가운데 몇 가지 중요한 내용만을 살펴보겠습니다.

닫힘 규칙
닫힘 규칙은 아주 간단한 규칙입니다. 즉, JSX의 모든 태그는 여는 태그가 있으면 반드시 닫는 태그도 있어야 한다는 규칙입니다.
이 규칙이 어떤 것인지 알아보기 위해 의도적으로 위반해 보겠습니다. 처음 보는 규칙을 익힐 때 좋은 방법의 하나는 그것을 위반해 보는 겁니다.
Body.js를 다음과 같이 수정합니다.

      <h2>{objA.a}</h2>
      <h2>{objA.b}
    
JSX 문법 오류가 발생하면 비주얼 스튜디오 코드에서는 붉은 밑줄로 오류가 있다고 표시합니다. 
많이 사용하는 HTML 태그 중 <img>, <input>은 닫힘 태그 없이도 사용할 수 있는데,
JSX에서는 이를 허용하지 않습니다. JSX에서 이 태그를 사용하려면 <img />, <input />과 같이 닫힘 태그를 반드시 병기해야 합니다.

최상위 태그 규칙
JSX가 반환하는 모든 태그는 반드시 최상위 태그로 감싸야 합니다


function Body() {
  const objA = {
    a:1,
    b:2,
  };
  return (
    <h1>body</h1>
    <h2>{objA.a}</h2>
    <h2>{objA.b}</h2>
  );
}

export default Body;

이 코드를 실행하면 Body 컴포넌트의 return 문 안에 최상위 태그가 존재하지 않아 오류가 발생합니다.
HTML 태그를 최상위 태그로 사용하지 않으려면, 다음과 같이 <React.Fragment>태그를 사용하면 됩니다.Z

=========================================================================================================
import React from "react";  // (1)

function Body() {
  const objA = {
    a:1,
    b:2,
  };
  return (
    <React.Fragment>
      <h1>body</h1>
      <h2>{objA.a}</h2>
      <h2>{objA.b}</h2>
    </React.Fragment>
  );
}

export default Body;
====================================================================================
(1) React.Fragment 태그는 리액트가 제공하는 기능이면서 컴포넌트입니다. 
따라서 Body.js에서 이 객체를 react 라이브러리에서 불러와야 합니다.

<React.Fragment>로 다른 태그를 감싸면 최상위 태그를 개체하는 효과가 있습니다.
단 페이지에서 <React.Fragment> 태그는 렌더링되지 않습니다.
변경한 파일을 저장하고 개발자 도구의 [Element] 탭을 클릭합니다.
<React.Fragment>는 보이지 않고 두 개의 <div> 태그만 렌더링하는 것을 확인할 수 있습니다.


<React.Fragment> 대신 빈 태그 <></>를 사용할 수도 있습니다.
그러면 빈 태그가 최상위 태그 역할을 수행합니다.
==================================================================
import React from "react";

function Body() {
  const objA = {
    a:1,
    b:2,
  };
  return (
    <>
      <h1>body</h1>
      <h2>{objA.a}</h2>
      <h2>{objA.b}</h2>
    </>
  );
}

export default Body;
==================================================================


조건부 렌더링==========================================================================================================
리액트 컴포넌트가 조건식의 결과에 따라 각기 다른 값을 페이지에 랜더링하는 것을 조건부 렌더링이라고 합니다.
그렇다면 조건부 렌더링은 주로 어떤 경우에 사용하는 걸까요?
페이스북 게시물의 좋아요 버튼을 생각해보겠습니다.
이 버튼은 사용자가 이미 좋아요를 눌렀다면 파란색, 그렇지 않으면 회색으로 표시합니다.
조건에 따라 페이지 요소의 모습이나 종류를 다르게 표시하고 싶을 때 조건부 렌더링을 사용합니다.

삼항 연산자를 활용한 조건부 렌더링
삼항 연산자를 활용하는 JSX 문법으로 조건부 렌더링을 구현할 수 있습니다.
component 폴더의 Body.js를 다음과 같이 수정합니다.


==================================================================
import React from "react";

function Body() {
  const num = 19;
  return (
    <>
      <h1>body</h1>
      <h2>
        {num}은(는) {num % 2 === 0 ? "짝수" : "홀수"}입니다.
      </h2>
    </>
  );
}

export default Body;
==================================================================
if 조건문은 표현식에 해당하지 않기 때문에 JSX와 함께 사용할 수 없지만,
표현식인 삼항 연산자를 이용하면 조건에 따른 다른 값을 렌더링할 수 있습니다.


조건문을 이용한 조건부 렌더링
조건문은 자바스크립트의 표현식이 아니기 때문에 JSX와 함께 사용할 수 없지만,
다음과 같이 조건에 따라 컴포넌트가 반환하는 값을 다르게 표시하도록 만들 수 있습니다.

==============================================
import React from "react";

function Body() {
  const num = 20;
  
  if(num % 2 === 0) {
    return <div>{num}은 짝수입니다.</div>
  } else {
    return <div>{num}은 홀수입니다.</div>
  }
}

export default Body;
========================================

삼항 연산자를 이용하는 방법과 조건문을 이용하는 방법은 각기 장단점이 있습니다.
삼항 연산자는 코드가 매우 간결하지만, 자주 사용할 경우 가독성을 해칠 우려가 있습니다.
그리고 삼항 연산자는 다중 조건을 작성하기 힘듭니다. 반면 조건문은 가독성이 좋으나
기본적으로 작성해야 할 코드가 많고 중복 코드가 발생할 우려도 있습니다.
따라서 여러분이 처한 상황에 맞게 적절히 선택해 사용하면 좋습니다.

JSXt스타일링=====================================
이번에는 JSX로 리액트 컴포넌트를 스타일링하는 방법을 살펴보겠습니다. 
스타일링이란 CSS와 같은 스타일 규칙을 이용해 요소의 크기, 색상 등을 결정하는 일입니다.

인라인 스타일링
인라인 스타일링이란 JSX 문법 중 하나로 HTML의 style 속성을 이용해 직접 스타일을 정의하는 방법입니다.


Body.js
============================================================
function Body() {
  return (
    <div style={{ backgroundColor: 'red', color: 'blue' }}> //(1)
      <h1>body</h1>
    </div>
  );
}
export default Body;
============================================================
(1) JSX의 인라인 스타일링은 style={{스타일 규칙}}과 같은 문법으로 작성합니다.
문자열로 작성하는 HTML의 인라인 스타일과 달리, JSX의 인라인 스타일링은 객체를 생성한 다음
각각의 스타일을 프로퍼티 형식으로 작성합니다. 또한 리액트의 JSX는 background-color 처럼 CSS에서
속성을 표시할 때 사용하는 스네이크 케이스 대신 카멜 표기법을 사용합니다.


스타일 파일 분리
HTML에서는 스타일을 정의한 CSS 파일을 따로 작성한 다음, link 형식으로 불러와 사용합니다.
리액트의 JSX도 맟찬가지로 별도의 CSS 스타일 파일을 만들고 이를 불러와 스타일을 적용할 수 있습니다.
Body 컴포넌트에 스타일 규칙을 적용할 파일 Body.css를 component 폴더에 만들고 다음과 같이 작성합니다.

Body.css
============================================================
.body {
  background-color: green;
  color: blue;
}
============================================================
Body.js에서 className 이 body인 요소의 배경색을 초록색으로 글자 색은 파란색으로 지정하는 style.css를 작성합니다.
다음에는 Body.css에 작성한 스타일 규칙을 컴포넌트에 적용하기 위해 Body.js를 다음과 같이 수정합니다.

import './Body.css';

function Body() {
  return (
    <div className='body'>
      <h1>body</h1>
    </div>
  );
}

export default Body;

1. CSS 파일은 import 문으로 경로만 명시하면 불러올 수 있습니다.
2. JSX에서는 HTML 문법과는 달리 요소의 이름을 지정할 때 class 선택자가 아닌 className을 사용합니다.




=======================================================================================================================
컴포넌트에 값 전달하기
리액트 앱을 만들다 보면 컴포넌트가 다른 컴포넌트에 값을 전달해야 하는 상황이 생깁니다.
이번 절에서는 컴포넌트 간에 값을 주고받는 방법을 알아보겠습니다.

Porps란?
리액트에서는 부모가 자식 컴포넌트에 단일 객체 형태로 값을 전달할 수 있습니다.
이 객체를 리액트에서는 Props(properties)라고 합니다.
Props는 Properties의 줄임말로 속성이라는 뜻입니다.

Props 객체가 왜 이런 이름을 갖게 되었는지 이해하려면, 컴포넌트가 어떤 상황에서 자식에게 값을 전달하는지 알아야합니다.
물론 Props라는 이름이 왜 붙었는지 몰라도 문제는 없습니다.

리액틍 에서는 보통 재사용하려는 요소를 컴포넌트로 만듭니다.
예를 들어 게시판 페이지를 리액트로 만든다고 가정해봅시다. 사용자가 게시판에서 작성한 글은
게시물 리스트에서 하나의 항목으로 표시됩니다. 그런데 이 리스트에 존재하는 여러 게시물 항목은 내용은 각각 다르지만,
모두 동일한 구조입니다. 리액트에서는 내용은 다르지만 구조가 같은 요소를 주로 컴포넌트로 만듭니다.
여러 게시물 리스트를 페이지에 표시할 때는 이 컴포넌트를 반복해 렌더링하고 게시물 각가의 내용은 Props로 전달합니다.



Props로 값 전달하기
그럼 컴포넌트에 Props를 전달하겠습니다.
Body 컴포넌트에 있는 변수 name을 Props로 전달합니다.
여기서 한 가지 주의할 사항이 있습니다. Props는 부모만이 자식 컴포넌트에 전달할 수 있습니다.
그 역은 성립하지 않습니다. 따라서 Body 컴포넌트에 Props를 전달하려면 부모인 App 컴포넌트에서 전달해야 합니다.

props로 하나의 값 전달하기
App.js를 다음과 같이 수정합니다.

import './App.css';
import Header from './component/Header';
import Body from './component/Body';
import Footer from './component/Footer';

function App() {
  const name = '이정환';
  return (
    <div className="App">  
      <Header />
      <Body name={name} />  // (1)
      <Footer />
    </div>
  );
}
export default App;

(1) Props를 전달하려는 자식 컴포넌트 태그에서 이름={값}형식으로 작성하면 됩니다.

전달하는 Props는 단일 객체입니다. 따라서 객체 Props에는 name 포로퍼티가 추가됩니다.

이번에는 App에서 전달한 Props를 Body 컴포넌트에서 사용하겠습니다.
Body.js에서 기존 내용을 모두 지우고 다음과 같이 작성합니다.

Body.js
======================================================================
import './Body.css';

function Body(props) {    // (1)
  console.log(props);      // (2)
  return <div className='body'>{props.name}</div>; //(3)
}
======================================================================
(1) 
부모 컴포넌트에서 전달된 객체 Props는 함수의 매개변수 형태로 저장됩니다.
이 코드에서는 Props라는 이름의 매개변수에 저장됩니다.
(2)
매개변수 props의 값을 확인하기 위해 개발자 도구의 콘솔에 출력합니다.
(3)
객체 props의 name 프로퍼티 값을 랜더링합니다.



Props로 여러 개의 값 전달하기============================================================
이번에는 App에서 Body 컴포넌트에 객체 Props로 여러 개의 값을 담아 전달하겠습니다.
먼저 App 컴포넌트를 다음과 같이 수정합니다.

import './App.css';
import Header from './component/Header';
import Body from './component/Body';
import Footer from './component/Footer';

function App() {
  const name = '이정환';
  return (
    <div className="App">
      <Header />
      <Body name={name} location={'부천시'} />  // (1)
      <Footer />
    </div>
  );
}

export default App;

(1)
App에서 Body 컴포넌트에 Props로 2개의 값 name, location을 전달합니다.
변수를 미리 선언하지 않아도 location={'부천시'} 처럼 객체 Props에 프로퍼티를 추가해 전달할 수 있습니다.

이번에는 Body 컴포넌트에서 Props로 전달된 2개의 값을 사용하겠습니다.

========== 1번 객체 점표기법으로 Props 사용===============

import './Body.css'

function Body(props) {
  console.log(props);
  return (
    <div className="body">
      {props.name}은 {props.location}에 거주합니다.
    </div>
  );
}

export default Body;


구조 분해 할당으로 여러 개의 값 사용하기========================================
Props로 전달된 값이 많으면, 이 값을 사용할 때마다 객체의 점 표기법을 사용해야 해서 여간 불편한게 아닙니다.
그런데 Props는 객체 이므로 구조 분해 할당하면 간단하게 사용할 수 있습니다.

========== 2번 객체 구조분해할당으로 Props 사용===============
import './Body.css'

function Body(props) {
  const { name, location } = props;    // (1)
  return (
    <div className="body">
      {name}은 {location}에 거주합니다.
    </div>
  );
}

export default Body;


========== 3번 매개변수 구조 분해로 Props 사용===============
import './Body.css'

function Body({ name, location }) {
  return (
    <div className="body">
      {name}은 {location}에 거주합니다.
    </div>
  );
}

export default Body;

이 코드의 결과는 앞의 코드와 동일합니다.
두 가지 방식 모두 큰 차이점은 없으나 실무에서는 매개변수에 구조 분해 할당하는 방식이 더 간결한 코드를 작성할 수 있어 선호하는 편입니다.


스프레드 연산자로 여러 개의 값 쉽게 전달하기=======================================================
반대로 부모 컴포넌트에서 Props로 전달할 값이 많으면, 값을 일일이 명시해야 하므로 불편할 뿐만 아니라 가독성도 떨어집니다.
이때 Props로 값을 하나의 객체로 만든 다음, 스프레드 연산자를 활용해 전달하면 훨씬 간결하게 코드를 작성할 수 있습니다.

다음과 같이 App에서 Body 컴포넌트에 전달할 값을 객체로 만든다음, 스프레드 연산자를 이용해 객체의 프로퍼티를 각각 props값으로 전달합니다.

App.js
======================== 부모 컴포넌트에서 보낼 props가 많을경우 객체로 만들어서 스프레드 사용 ======================================
function App() {
  const BodyProps = {
    name: '이정환',
    location: '부천시',
  };

  return (
    <div className="App">
      <Header />
      <Body {...BodyProps} />
      <Footer />
    </div>
  ); 
}


기본값 설정하기
App에서 Body 컴포넌트에 전달할 값을 하나 더 늘리겠습니다.

App.js
====================================================
import './App.css';
import Header from './component/Header';
import Body from './component/Body';
import Footer from './component/Footer';

function App() {
  const BodyProps = {
    name: '이정환',
    location: '부천시',
    favorList: ['파스타', '빵', '떡볶이'],
  };

  return (
    <div className="App">
      <Header />
      <Body {...BodyProps} />
      <Footer />
    </div>
  );
}

export default App;
=================================================================


Body 컴포넌트에서 좋아하는 음식의 개수를 페이지에 랜더링하겠습니다.

Body.js
=============================================================================
import './Body.css'

function Body({ name, location, favorList }) {
  return (
    <div className="body">
      {name}은 {location}에 거주합니다.
      <br />
      그리고 좋아하는 음식의 개수는 {favorList.length}개 입니다.
    </div>
  );
}

export default Body;
=================================================================


그런데 실수로 App 컴포넌트에서 Props의 값중 favorList를 전달하지 않으면 어떻게 될까요?
다음과 같이 App 컴포넌트를 수정하겠습니다.

====================================================
import './App.css';
import Header from './component/Header';
import Body from './component/Body';
import Footer from './component/Footer';

function App() {
  const BodyProps = {
    name: '이정환',
    location: '부천시',
    // favorList: ['파스타', '빵', '떡볶이'],
  };

  return (
    <div className="App">
      <Header />
      <Body {...BodyProps} />
      <Footer />
    </div>
  );
}

export default App;
=================================================================
결과를 확인하면 오류가 발생합니다.
App에서 실수로 favorList를 전달하지 않으면 Body 컴포넌트의 배열 favorList의 값은 undefined가 됩니다.
Body 컴포넌트에서는 favorList를 배열로 예상하고, 배열의 길이를 랜더링하기 위해 length 포로퍼티를 접근합니다.
따라서 undefined 프로퍼티를 읽을 수 없다는 메시지와 함게 오류가 발생합니다.

이런 경우를 대비해 defaultProps를 사용합니다.
defaultProps를 이용하면 컴포넌트가 받을 Props의 기본값을 미리 설정할 수 있기 때문에 오류를 미연에 방지할 수 있습니다.


====================================================
import './Body.css'

function Body({ name, location, favorList }) {
  return (
    <div className="body">
      {name}은 {location}에 거주합니다.
      <br />
      그리고 좋아하는 음식의 개수는 {favorList.length}개 입니다.
    </div>
  );
}

Body.defaultProps = {
  favorList: []
}

export default Body;
=================================================================


Props로 컴포넌트 전달하기================================================================================
지금까지 컴포넌트 간에 Props로 문자열이나 숫자 같은 자바스크립트 값을 전달해 보았습니다.
그런데 Props로는 자바스크립트 값뿐만 아니라 컴포넌트도 전달할 수 있습니다.
이번에는 App에서 Body로 컴포넌트를 하나 전달하겠습니다.

App.js
====================================================
function ChildComp() {
  return <div>child component</div>;
}

function App() {


  return (
    <div className="App">
      <Header />
      <Body>
        <ChildComp />
      </Body>
      <Footer />
    </div>
  );
}

export default App;
=================================================================
Body 컴포넌트의 자식 요소로 ChildComp를 배치했습니다. 
리액트 에서는 자식 컴포넌트에 또다른 컴포넌트를 배치하면, 배치된 컴포넌트는 자동으로 Props의 children 프로퍼티에 저장되어 전달됩니다.
children 프로퍼티에 저장된 자식 컴포넌트를 사용하겠습니다. Body 컴포넌트를 다음과 같이 수정합니다.


Body.js
====================================================
import './Body.css'

function Body({children}) {
  return (
    <div className='body'>{children}</div>
  );
}

export default Body;
=================================================================



이벤트
이벤트 처리하기=================================================================
이벤트란 웹 페이지에서 일어나는 사용자의 행위입니다.
버튼 클릭, 페이지 스크롤, 새로고침 등이 이런 행위에 해당합니다.
따라서 사용자가 버튼을 클릭하면 버튼 클릭 이벤트, 텍스트를 입력하면 텍스트 변경 이벤트가 발생했다고 표현합니다.
이번 절에서는 리액트에서 어떻게 이벤트를 처리하는지 살펴보겠습니다.

이벤트 핸들링과 이벤트 핸들러
이벤트 핸들링은 이벤트가 발생하면 특정 코드가 동작하도록 만드는 작업입니다.
버튼을 클릭했을 때 경고 대화상자를 브라우저에 표시하는 동작이 이벤트 핸들링의 대표적인 예입니다.
다음은 리액트를 사용하지 않고 HTML과 자바스크립트만으로 이벤트를 핸들링하는 예입니다.


리액트의 이벤트 핸들링
리액트에서는 어떻게 이벤트를 핸들링하는지 살펴보겠습니다.
Body 컴포넌트에 버튼을 하나 만들고, 버튼을 클릭하는 이벤트가 발생하면 실행되는 이벤트 핸들러를 만들겠습니다.


Body.js
=====================================================================================
function Body() {
  function handleOnclick() {
    alert('버튼을 클릭하셨군요');
  }

  return (
    <div className="body">
      <button onClick={handleOnclick}>클릭하세요</button>
    </div>
  );
}

export default Body;
=====================================================================================

리액트의 이벤트 핸들링은 HTML의 이벤트 핸들링과 흡사하지만, 차이점이 몇가지 있습니다.
먼저 이벤트 핸들러 표기에서 HTML은 onclick이지만 리액트는 카멜 케이스 문법에 따라 onClick으로 표기합니다.
그리고 Props로 전달할 값을 지정할 때 처럼 onClick={} 문법으로 이벤트 핸들러를 설정합니다.
또한 이벤트 핸들러를 설정할 때는 함수 호출의 결괏값을 전달하는 것이 아니라 콜백 함수처럼 함수 그 자체를 전달합니다.


이벤트 객체 사용하기
리액트에서는 이벤트가 발생하면 이벤트 핸들러에게 이벤트 객체를 매개변수로 전달합니다.
이벤트 객체에는 이벤트가 어떤 요소에서 어떻게 발생했는지에 관한 정보가 상세히 담겨 있습니다.
이번에는 Body 컴포넌트에 2개의 버튼을 만들고, 이벤트가 발생하면 클릭한 버튼의 이름을 콘솔에 출력하겠습니다.

Body.js
=====================================================================================
import './Body.css';

function Body() {
  function handleOnclick(e) {
    console.log(e.target.type);
  }

  return (
    <div className="body">
      <button name='A버튼' onClick={handleOnclick}>A 버튼</button>
      <button name='B버튼' onClick={handleOnclick}>B 버튼</button>
    </div>
  );
}

export default Body;
=====================================================================================
이벤트 객체의 target 프로퍼티에는 이벤트가 발생한 페이지의 요소(여기서는 버튼)가 저장됩니다.
따라서 A버튼을 클릭하면 e.target에는 A 버튼이 저장되고, B 버튼을 클릭하면 e.target에는 B버튼이 저장됩니다.
따라서 함수 handleOnclick에서 e.target.name을 콘솔에 출력하면 현재 이벤트가 발생한 요소의 name 속성값을 출력하게 됩니다.

이벤트 객체를 확인합니다.
출력된 이벤트 객체를 살펴보면 상당히 많은 프로퍼티가 저장되어 있음을 알 수 있습니다.
그러나 아주 복잡한 이벤트 처리가 아니라면 실무에서는 대채로 1-2개의 값만 활용하므로 이 값들을 모두 상세히 알 필요는 없습니다.


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
컴포넌트와 상태    ================================================================
지금까지는 값이 변하지 않는 정정인 리액트 컴포넌트를 만들었습니다.
지금부터는 사용자의 행위나 시간 변동에 따라 값이 변하는 동적인 리액트 컴포넌트를 만들 차례입니다.
이를 위해서는 리액트의 핵심 기능 중 하나인 State르 알아야합니다.
이번 절에서는 State를 이용해 동적인 컴포넌트를 만드는 방법을 살펴보겠습니다.

++++++++++++++++++++++++++++++++++++ㅍ++++++++++++++++++++++++++++++++++++++++++++++++
state 이해하기   !~!~!~!~!~!~!~!~!~!~!~!~~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
State는 상태라는 뜻입니다.
상태는 어떤 사물의 형편이나 모양을 일컫는 말로 흔히 씁니다.
상태는 전구와 스위치에 빗대어 생각하면 쉽게 이해할 수 있습니다.
스위치를 끄면 전구에 불이 들어오지 않는데, 이를 소등 상태라고 할 수 있습니다.
반대로 스위치를 켜면 전구에 불이 들어오며 이를 점등 상태라고 할 수 있습니다.
전구의 상태 변화는 다음과 같이 정리할 수 있습니다.

- 전구의 상태는 소등과 점등으로 나눌 수 있다.
- 소등 상태일 때 스위치를 켜면 '점등'으로 상태 변화가 일어난다.
- 점등 상태일 때 스위치를 끄면 '소등'으로 상태 변화가 일어난다.

용어를 상태가 아닌 State로 변경하면 다음과 같습니다.

- 전구 state는 off(소등), on(점등) 둘 중 하나의 값을 갖는다.
- 전구 State의 값이 off일 때 스위치를 켜면 값이 on으로 바뀐다.
- 전구 State의 값이 on일 때 스위치를 끄면 값이 off로 바뀐다.

전구의 상태와 리액트 컴포넌트의 state는 매우 유사합니다.
전구의 상태가 상태 변화에 따라 점등 또는 소등으로 변하는 것처럼 리액트 컴포넌트 또한 state 값에 따라 다른 결과를 렌더링합니다.

State의 기본 사용법
직접 State를 만드는 실습을 하면서 리액트의 State가 어떤 개념인지 자세히 알아보겠습니다.

useState로 State 생성하기
리액트에서는 함수 useState로 State를 생성합니다.
useState의 문법은 다음과 같습니다.

[useState의 용법]
const [light, setLight] = useState('off');
      state변수, set함수     생성자(초기값)

useState를 호출하면 2개의 요소가 담긴 배열을 반환합니다.
이때 배열의 첫 번째 요소 light는 현재 상태의 값을 저장하고 있는 변수,
이 변수를 State변수라고 한다.
다음으로 두 번재 요소인 setLight는 state 변수의 값을 변경하는 즉 상태를 업데이트하는 함수입니다.
이 함수를 set함수 라 부릅니다.
useState를 호출할 때 인수로 값을 전달하면 이 값이 State의 초깃값이 됩니다. 
위 코드에서는 'off'를 전달했으므로 State 변수 light의 초깃값은 off가 된다.

Body 컴포넌트에서 숫자를 카운트 할 수 있는 State 변수 count를 생성하겠습니다.


Body.js
=====================================================================================
import { useState } from 'react';   // (1)
import './Body.css';

function Body() {
  const [count, setCount] = useState(0);  // (2)
  return (
    <div>
      <h2>{ count }</h2>
    </div>
  );
}

export default Body;
=====================================================================================
(1)
useState는 리액트가 제공하는 State를 만드는 함수입니다.
State를 만들기 위해 useState를 react라이브러리에서 불러옵니다.
(2)
함수 useState는 인수로 State의 초깃값을 전달합니다.
코드에서는 초깃값으로 0을 전달합니다.
그 결과 State 변수 count와 set 함수 setCount를 반환합니다.

%%%$$%$%$%$$%$$%$%%%%$$%$%$%$$%$$%$%%%%$$%$%$%$$%$$%$%%%%$$%$%$%$$%$$%$%%%%$$%$%$%$$%$$%$%
set함수로 State 값 변경하기    !@!@!!@!~@~!@~!@~@~!@~!@~!@~@!~!@~!@~!@~!@~!@~!@~!@~!@~!@
이번에는 set 함수를 호출해 State 값을 변경하겠습니다.
컴포넌트에서 버튼을 하나 만들고, 버튼을 클릭할 때 마다 State(count) 값을 1씩 늘리겠습니다.
Body 컴포넌트를 다음과 같이 수정합니다.


Body.js
=====================================================================================
import { useState } from 'react';
import './Body.css';

function Body() {
  const [count, setCount] = useState(0);
  const onIncrease = () => {   //  (1)
    setCount(count + 1);
  };

  return (
    <div>
      <h2>{ count }</h2>
      <button onClick={onIncrease}>++</button>
    </div>
  );
}

export default Body;
=====================================================================================
(1)
버튼의 이벤트 핸들러 onIncrease에서는 set 함수인 setCount를 호출합니다.
인수로 count에 1 더한 값을 전달합니다.

페이지에서 ++ 버튼을 클릭하면 onIncrease 이벤트 헨들러가 실행됩니다.
함수 onIncrease는 setCount를 호출하고, 인수로 현재의 count 값에 1더한 값을 전달합니다.
그 결과 State(count) 값은 1증가합니다.

이렇듯 set 함수를 호출해 State 값을 변경하면, 변경값을 페이지에 반영하기 위해 컴포넌트를 다시 랜더링합니다.
리액트에서는 이것을 컴포넌트의 업테이트라고 표현합니다.
컴포넌트가 페이지에 랜더링하는 값은 컴포넌트 함수의 반환값입니다.
따라서 컴포넌트를 다시 랜더링하다고 함은 컴포넌트 함수를 다시 호출한다는 의미와 같습니다.

컴포넌트 함수를 다시 호출한다는 게 어떤 의미인지 직접 확인해 보겠습니다.
디음과 같이 호출할 때마다 콘솔에 문자열 update!를 출력하도록 Body컴포넌트를 수정합니다.


State로 사용자 입력 괸리하기
웹 사이트에서는 다양한 입력 폼을 제공하는데, 사용자는 이 입력 폼을 이용해 텍스트, 숫자, 날짜 등의 정보를 입력합니다.
HTML에서 입력 폼을 만드는 태그로는 다양한 형식의 정보를 입력할 수 있는 <input>태그,
여러 옵션에서 하나를 선택하도록 목록을 보여주는 <select> 태그, 여러 중의 텍스트를 입력할 수 있는 <textarea> 태그 등이 있습니다.
입력 폼은 로그인, 회원 가입, 게시판, 댓글 등이 필요한 페이지에서 자주 활용되는 웹 개발의 필수요소입니다.
리액트에서 State를 이용하면 다양한 입력폼에서 제공되는 사용자 정보를 효과적으로 처리할 수 있습니다.

<input> 태그로 텍스트 입력하기
처음 다룰 입력 폼은 텍스트, 전화번호, 날짜, 체크박스 등 여러 형식의 정보를 입력할 수 있는 <input>태그가 만드는 폼입니다.
<input> 태그로 텍스트를 입력하는 폼을 하나 만들고, 사용자가 텍스트를 입력할 때마다 콘솔에 출력하는 이벤트 핸들러를 구현해보겠습니다.


Body.js
=====================================================================================
function Body() {
  const handleOnChange = e => {       //   (1)
    console.log(e.target.value);
  }

  return (
    <div>
      <input onChange={handleOnChange} />    //  (2)
    </div>
  );
}

export default Body;
=====================================================================================
(1)
입력 폼에서 이벤트 핸들러로 사용할 함수 handleOnChange를 만듭니다.
이 함수는 이벤트 객체를 매개변수로 저장해 사용자가 폼에 입력한 값(e.target.value)을 콘솔에 출력합니다.
(2)
<input> 태그로 텍스트를 입력할 폼을 만들고, 이 폼의 onChange 이벤트 헨들러로 handleOnChange를 설정합니다.

onChange 이벤트는 사용자가 입력 폼에서 텍스트를 입력하면 바로 동작합니다.

이 상태로도 텍스트 입력 폼을 이용해 사용자에게 입력을 받을 수 있습니다.
그러나 지금은 사용자가 입력한 텍스트가 리액트 컴포넌트가 관리하는 state에 저장되어 있지 않습니다.
따라서 만약 버튼을 클릭했을 때 사용자가 입력한 텍스트를 콘솔에 출력하는 등의 동작을 수행하게 하려면
DOM API를 이용하는 등 번거로운 작업이 별도로 요구됩니다.

따라서 state를 하나 만들고 사용자가 폼에서 입력할 때마다 텍스트를 state 값으로 저장하겠습니다.
Body.js
=====================================================================================
import {useState} from 'react';

function Body() {
  const [text, setText] = useState('');   // (1)
  const handleOnChange = e => {
    setText(e.target.value);    //  (2)
  }
  return (
    <div>
      <input value={text} onChange={handleOnChange}/>  // (3)
      <div>{text}</div>   // (4)
    </div>
  );
}

export default Body;
=====================================================================================
(1)
빈 문자열을 초기값으로 하는 state 변수 text 생성
(2)
폼에 입력한 텍스트를 변경할 때마다 set 함수를 호출해 text 값을 현재 입력한 텍스트로 변경
(3)
<input> 태그의 value 속성에 state 변수 text를 설정
(4)
변수 text의 값을 페이지에 렌더링합니다.

정리하면 입력폼에서 사용자가 텍스트를 입력하면 onChange 이벤트가 발생해
이벤트 핸들러 handleOnChange를 호출합니다.
handleOnChange는 내부에서 set 함수를 호출하는데, 인수로 현재 사용자가 입력한 텍스트를 전달합니다.
그 결과 사용자가 폼에서 입력한 값은 text에 저장되면서 state값을 업데이트합니다.
state 값이 변경되면 컴포넌트는 자동으로 리렌더됩니다.
따라서 페이지에서는 현재의 state 값을 다시 렌더링합니다.


<input /> 태그로 날짜 입력하기
Body.js
=====================================================================================
import { useState } from 'react';
import './Body.css';

function Body() {
  const [date, setDate] = useState('');
  const handleOnChange = e => {
    console.log(e.target.value)
    setDate(e.target.value)
  }

  return (
    <div>
      <input type='date' value={date} onChange={handleOnChange}/>
    </div>
  );
}

export default Body;
=====================================================================================

드롭다운 상자로 여러 옵션 중에 하나 선택하기
<select> 태그는 <option>과 함께 사용합니다.
이 태그를 사용하면 드롭다운 메뉴로 여러 목록을 나열해 보여 주는 입력 폼이 만들어진다.
이 폼 목록에서 하나를 선택하면 해당 항목을 입력할 수 있습니다.
드롭다운 입력 폼은 쇼핑몰 사이트에서 여러 옵션을 선택할 때 자주 활용됩니다.
드롭다운 입력 폼에서 입력한 값을 state로 어떻게 처리하는지 알아보겠습니다.

Body.js
=====================================================================================
import { useState } from 'react';
import './Body.css';

function Body() {
  const [option, setOption] = useState('');
  const handleOnChange = e => {
    setOption(e.target.value);

    console.log(e.target)
    console.dir(e.target)
    console.log('e.target.value', e.target.value)
    console.log('option', option)
  }
  return (
    <div>
      <select value={option} onChange={handleOnChange}>
        <option>1번</option>
        <option>2번</option>
        <option>3번</option>
      </select>
    </div>
  );
}

export default Body;
=====================================================================================
드롭다운 입력 폼에서 사용자가 옵션을 변경하면 onChange 이벤트가 발생합니다.

이 상태에서 콘솔창을 확인하면 이벤트 핸들러 함수 내에서 option은 처음 메뉴를 선택했을 때 빈 문자열이 출력된다.
그 이유는 useState함수가 비동기적으로 상태를 업데이트하기 때문이다.

react에서 useState를 사용하면 상태를 업데이트하는 함수 setOption이 비동기적으로 작동한다.
즉, 상태가 변경되더라도 해당 변경이 즉시 반영되지 않을 수 있다.
따라서 console.log('option', option)을 호출할 때 option 변수의 값은 업데이트 이전의 값, 즉 빈 문자열인 상태로 남아 있다.

e.target.value를 통해 새로운 값을 option 상태에 설정하는 setOption 함수가 호출되면 React는 이벤트 헨들러 내의 코드를 실행하고
다음 렌더링 사이클에서 상태를 업데이트합니다.
따라서 console.log('option', option)은 상태 업데이트 이전의 값을 출력하게 된다.

상태 업데이트 이후에 새로운 값에 접근하려면 React의 렌더링 사이클 완료후에 실행되는 useEffect 훅을 사용할 수 있습니다.

Body.js
=====================================================================================
import { useState, useEffect } from 'react';


function Body() {
  const [option, setOption] = useState('');

  useEffect(() => {
    console.log('option', option);
  }, [option]);

  const handleOnChange = e => {
    setOption(e.target.value);
  }

  return (
    <div>
      <select value={option} onChange={handleOnChange}>
        <option>1번</option>
        <option>2번</option>
        <option>3번</option>
      </select>
    </div>
  );
}

export default Body;

=====================================================================================
이렇게 하면 useEffect가 option 값이 변경될 때마다 호출되고, 업데이트된 option 값을 출력하게 됩니다.


글상자로 여러 줄의 텍스트 입력하기
<textarea> 태그는 사용자가 여러 줄의 텍스트를 입력할 때 사용하는 폼을 만듭니다.
이 폼은 웹 페이지에서 사용자가 자기소개와 같이 여러 줄의 내용을 입력할 때 주로 활용됩니다.
이 폼을 편의상 글상자라고 하겠습니다.
이번에는 리엑트에서 글상자에 이력한 내용을 state로 어떻게 처리하는지 알아보겠습니다.


여러 개의 사용자 입력 관리하기
지금까지 리액트의 state를 이용해 컴포넌트에서 사용자의 입력을 처리하는 방법을 알아보았습니다.
그런데 회원 가입을 유도하는 페이지에는 사용자의 입력 폼이 하나가 아니라 작게는 3개, 많게는 10개까지 되는 곳도 있습니다.

이번에는 여러 개의 사용자 입력을 state로 관리하는 방법을 살펴보겠습니다.
이름, 성별, 출생 연도, 자기소개 등을 한 번에 입력할 수 있도록 Body 컴포넌트를 다음과 같이 수정합니다.



Body.js
=====================================================================================
import { useState } from 'react';
import './Body.css';

function Body() {
  const [name, setName] = useState('');
  const [gender, setGneder] = useState('');
  const [birth, setBirth] = useState('');
  const [bio, setBio] = useState('');

  const onChangeName = e => {
    setName(e.target.value);
  }
  const onChangeGender = e => {
    setGneder(e.target.value);
  }
  const onChangeBirth = e => {
    setBirth(e.target.value);
  }
  const onChangeBio = e => {
    setBio(e.target.value);
  }

  return (
    <div>
      <div>
        <input value={name} placeholder='이름' onChange={onChangeName}/>
      </div>
      <div>
        <select value={gender} onChange={onChangeGender}>
          <option></option>
          <option>남성</option>
          <option>여성</option>
        </select>
      </div>
      <div>
        <input value={birth} type={'date'} onChange={onChangeBirth} />
      </div>
      <div>
        <textarea value={bio} onChange={onChangeBio} />
      </div>
    </div>
  ); 
}

export default Body;

=====================================================================================

총 4개의 state 변수와 이벤트 핸들러를 생성합니다.
저장한 다음, 4개의 입력 폼이 잘 나타나는지 값은 잘 입력되는지 확인합니다.

사용자로부터 여러 정보 입력을 받아 state로 처리하는 경우,
관리할 state의 개수가 많아지면 코드의 길이 또한 길어집니다.
객체 자료형을 이용하면 입력 내용이 여러 가지라도 하나의 state에서 관리할 수 있어 더 간결하게 코드를 작성할 수 있습니다.


Body.js
=====================================================================================
import { useState } from 'react';
import './Body.css';

function Body() {
  const [state, setState] = useState({
    name: '',
    gender: '',
    birth: '',
    bio: ''
  });

  const handleOnChange = e => {
    console.log('현재 수정 대상', e.target.name);
    console.log('수정값', e.target.value);
    setState({
      ...state,
      [e.target.name]: e.target.value
    })
  }

  return (
    <div>
      <div>
        <input 
          name='name'
          value={state.name}
          onChange={handleOnChange}
          placeholder='이름'
        />
      </div>
      <div>
        <select name='gender' value={state.gender} onChange={handleOnChange}>
          <option></option>
          <option>남성</option>
          <option>여성</option>
        </select>
      </div>
      <div>
        <input
          name='birth'
          type='date'
          value={state.birth}
          onChange={handleOnChange}
        />
      </div>
      <div>
        <textarea name='bio' value={state.bio} onChange={handleOnChange} />
      </div>
    </div>
  );
}

export default Body;

=====================================================================================

호울하는 이벤트 핸들러 handleOnChange는 이벤트 객체 e를 매개변수로 저장하고 다음과 같이 setState를 호출합니다.
setState({
  ...state,
  [e.target.name]: e.target.value;
})

함수 setState에서는 새로운 객체를 생성해 전달합니다. 이때 스프레드 연산자를 이용해
기존 객ㅊ체 state의 값을 나열합니다. 그리고 객체의 괄호 표기법을 사용하여
입력 폼의 name 속성(e.target.name)을 key로, 입력 폼에 입력한 값(e.target.value)을 value로 저장합니다.
e.target.name은 현재 이벤트가 발생한 요소의 name 속성입니다.
예를 들어 성별을 입력하는 select 태그에서 onChange 이벤트가 발생했다면, 
e.target.name은 gender가 됩니다. 결국 객체 state의 4가지 프로퍼티 중 현재 이벤트가 발생한 요소인 gender 프로퍼티의 value값을
변경하게 됩니다.
객체 자료형을 이용하면 하나의 state로 여러 개의 입력을 동시에 관리할 수 있습니다.
저장한 다음, 페이지에서 이름은 1 성별은 남성, 날짜는 오늘 날짜, 자시소개는 1을 각각 입력한 다음 콘솔에서 확인합니다.



props와 state =======================
동적으로 변하는 갓ㅂ인 리액트의 state 역시 일종의 값이므로 props로 전달할 수 있습니다.
이번에는 Body에 자식 컴포넌트를 만들고 Body의 state를 props로 전달합니다.


Body.js
=====================================================================================
import { useState } from 'react';
import './Body.css';

const Viewer = ({number}) => {    // (1)
  return (
    <div>
      {number % 2 === 0 ? <h3>'짝수'</h3> : <h3>'홀수'</h3>}
    </div>
  );
}

const Body = () => {
  const [number, setNumber] = useState(0);

  const onDecrease = () => {
    setNumber(number - 1);
  }

  const onIncrease = () => {
    setNumber(number + 1);
  }


  return (
    <div>
      <h2>{number}</h2>
      <Viewer number={number}/>   // (2)

      <div>
        <button onClick={onIncrease}>+</button>
        <button onClick={onDecrease}>-</button>
      </div>
    </div>
  );
}

export default Body;

=====================================================================================
(1)
viewer 컴포넌트를 선언합니다. 이 컴포넌트에는 Props로 Body 컴포논트에 있는 state 변수 number가 전달됩니다.
viewer 컴포넌트는 조건부 렌더링을 이용해서 변수 number의 값을 평가하고, 값에 따라 짝수 또는 홀수 값을 렌더링합니다.
(2)
Body에서 viewer 를 자식 컴포넌트로 사용하며, props로 변수 number를 전달합니다.

여기서 알 수 있는 중요한 사실이 있습니다.
바로 자식 컴포넌트는 props로 전달된 state값이 변하면 자신도 리렌더된다는 사실입니다.
즉, 부모에 속해 있는 state(number)값이 변하면 viewer 컴포넌트에서 구현한 짝수, 홀수 값도 따라서 변합니다.

state와 자식 컴포넌트
부모의 state 값이 변하면 해당 state를 props로 받은 자식 컴포넌트도 역시 리렌더 된다.
그렇다면 부모 컴포넌트가 자식에게 state를 props로 전달하지 않는 경우는 어떻게 될까요?
그래도 부모 컴포넌트의 state가 변하면 자식 컴포넌트도 리렌더 될까요?

Body.js
=====================================================================================
import { useState } from 'react';
import './Body.css';

const Viewer = () => {
  console.log('viewer component update')

  return (
    <div>
       <div>Viewer</div>
    </div>
  );
}

const Body = () => {
  const [number, setNumber] = useState(0);

  const onDecrease = () => {
    setNumber(number - 1);
  }

  const onIncrease = () => {
    setNumber(number + 1);
  }


  return (
    <div>
      <h2>{number}</h2>
      <Viewer />

      <div>
        <button onClick={onIncrease}>+</button>
        <button onClick={onDecrease}>-</button>
      </div>
    </div>
  );
}

export default Body;

=====================================================================================

버튼을 5번 누른 다음 콘솔을 확인합니다.
콘솔에서 6번의 viewer component update 가 출력되었습니다.
첫 번째 콘솔은 viewer 컴포넌트를 페이지에 처음 렌더링할 때 출력된 것입니다.
나머지 5번은 부모인 Body 컴포넌트가 state가 변할 때마다 출력되었습니다.

리액트에서는 부모 컴포넌트가 리렌더되면 자식도 함께 리렌더 됩니다.



Ref  =========================================================
리액트의 Ref를 이용하면 돔(DOM) 요소들을 직접 조작할 수 있습니다.
Ref는 Ref-erence의 줄밈말로 참조라는 뜻입니다. 이 기능을 이용해 돔 요소를 제어해 보겠습니다.

useRef 사용하기 ==========================================
리엑트의 Ref를 이용하면 돔(DOM) 요소들을 직접 조작할 수 있습니다.
Ref는 Ref-erence의 줄임말로 참조라는 뜻입니다. 이번 절에서는 이 기능을 이용해 돔 요소를 제어해 보겠습니다.


Body.js
=====================================================================================
import { useRef, useState } from 'react';
import './Body.css'

const Body = () => {
  const [text, setText] = useState('');
  const textRef = useRef();

  const handleOnChange = e => {
    setText(e.target.value);
  }

  const handleOnClick = () => {
    alert(text)
  }

  return (
    <div>
      <input ref={textRef} value={text} onChange={handleOnChange} />
      <button onClick={handleOnClick} >작성완료</button>
    </div>
  );
}

export default Body;
=====================================================================================

state 변수 text로 관리하는 텍스트 입력 폼 하나와 버튼 하나 생성
버튼을 클릭하면 이벤트 헨들러 handleOnclick이 실행되어 입력 폼에서 작성한 텍스트를 메시지 
대화상자에 표시힙니다.

계속해서 돔 요소의 하나인 <input>태그의 입력 폼에 접근하는 Ref를 만들겠씁니다.
위와 같이 수정합니다.


useRef로 입력 폼 초기화하기
웹 서비스의 로그인 페이지는 대부분 사용자가 ID와 패스워드를 입력하고,
로그인 버튼을 클릭하면 패스워드가 올바른지 점검합니다.
그런 다음 패스워드 입력 폼에서 값을 초기화합니다.
리액트에서 Ref를 이용하면 이런 동작을 수행할 수 있습니다.
이번에는 useRef를 이용해 텍스트 입력 폼을 초기화하는 법을 알아보자

Body.js
=====================================================================================
import { useRef, useState } from 'react';
import './Body.css'

const Body = () => {
  const [text, setText] = useState('');
  const textRef = useRef();

  const handleOnChange = e => {
    setText(e.target.value);
  }

  const handleOnClick = () => {
    alert(text);
    textRef.current.value = '';   // (1)
  }

  return (
    <div>
      <input ref={textRef} value={text} onChange={handleOnChange} />
      <button onClick={handleOnClick} >작성완료</button>
    </div>
  );
}

export default Body;
=====================================================================================
(1)
버튼을 클릭해 이벤트 핸들러 handleOnClick을 실행합니다.
대화상자에서 확인 버튼을 클릭하면 textRef.current => textRef가 현재 참조하고 있는 돔 요소
의 value 값을 공백 문자열로 초기화합니다.

저장하고 텍스트 입력 폼에서 값을 입력한다음 작성완료 버튼을 클릭

텍스트 입력 폼에서 입력한 문자열이 사라지고 빈 공백만 남습니다. 이렇듯 Ref를 이용함ㄴ
돔 요소를 원하는 형태로 조작할 수 있습니다.

function MyComponent() {
  const myRef = useRef();

  const handleButtonClick = () => {
    // myRef.current를 사용하여 DOM 요소에 접근
    myRef.current.focus(); // 예: input 요소에 포커스를 줍니다.
  };

  return (
    <div>
      <input ref={myRef} />
      <button onClick={handleButtonClick}>포커스 주기</button>
    </div>
  );
}

useRef로 포커스하기
웹 서비스에서는 사용자가 특정 폼에 내용을 입력하지 않거나 내용이 정한 길이보자 짧으면 해당 폼을 
포커스하여 사용자의 추가 입력을 유도합니다.
리액트의 Ref 기능을 이용하면 특정 요소에 포커스 기능을 지정할 수 있습니다.

이번에는 텍스트 입력 폼에서 사용자가 다섯 글자 미만으로 입력하면 이 요소에 포커스한 상태로
사용자가 입력을 추가할 때까지 대기합니다.

리액트 훅
리액트 훅이란 함수로 만든 리액트 컴포넌트에서 
클래스로 만든 리액트 컴포넌트의 기능을 이용하도록 도와주는 함수입니다.

앞서 state를 만드는 함수 useState와 참조 객체를 만드는 함수 useRef는 모두 리액트 훅입니다.
이 두 함수를 모두 이름이 use로 시작하는데, 리액트 훅은 이름 앞에 항상 use를 붙입니다.

state와 Ref 모두 원래는 함수로 만든 컴포넌트에서는 사용할 수 없는 기능이지만 이 훅 기능 덕북에
사용할 수 있습니다.


프로젝트 주비하기
지금까지 배운 내용을 토대로 카운터 앱 프로젝트를 진행하겠습니다.
카운터 앱은 숫자를 더하고 빼는 기능만 있습니다.

프로젝트를 구현하기에 앞서 꼭 해야 할 일이 있습니다.
이 앱을 어떤 설꼐와 기능으로 구현할지 살펴보는 일입니다.
이를 소프트웨어 공학에서는 요구사항 분석이라고 하니다.
요구사항 분석은 마치 요리를 시작하기 전 레시피를 점검하는 일과 비슷합니다.
요구사항 분석 없이 프로젝트를 구현하면 중간에 코드를 다시 작성하는 일이 발생할 수 있으므로
반드시 거치는게 좋습니다.

요구사항 분석하기 ------=-=-=-=-=-=-=-=-==-
완성된 프로젝트를 보면서 이 앱에는 어떤 요구사항들이 있는지 확인해 보겠습니다.

이 앱은 하나의 페이지이며
simple Counter라고 적힌 제목을 제외하면 두 개의 영역으로 나누어져 있습니다.

 - 첫 번째 영역은 현재의 카운트를 표시합니다.
   따라서 이 영역의 이름을 뷰어라고 하겠습니다.

 - 두 번째 영역에서는 카운트를 늘리거나 줄일 수 있는 6개의 버튼이 가지런히 놓여 있습니다.
   카운트를 제어하는 영역이라는 의미에서 컨트롤러 라고 이름 붙이겠습니다.

컴포넌트 단위로 생각하기
리액트에서 앱을 구현할 때는 컴포넌트 단위로 생각하는 게 필요하니다.
앞에서 살펴본 viewer, controller 영역을 일종의 컴포넌트라고 생각하는 겁니다.
그럼 앱에는 어떤 컴포넌트들이 있는지 알아보겠습니다.

앱에서는 다음과 같은 역할을 하는 3개의 컴포넌트가 있습니다.

1. App 컴포넌트 : viewer, controller 컴포넌트를 감싸는 템플릿
2. viewer 컴포넌트 : 현재의 카운트를 표시함
3. controller 컴포넌트 : 카운트를 제어할 수 있는 기능을 제공함


리액트 앱 만들기
준비 과정의 마지막 단계는 리액트 앱을 만드는 작업입니다.
리액트 앱을 생성하는 방법은 같습니다.

UI 구현하기 -=-=-=-=-==-=-=-
앞서 요구 사항을 분석하고 리액트 앱을 생성해 프로젝트 구현 준비를 마쳤습니다.
이번에는 기능 구현에 앞서 UI를 구현하겠습니다.
UI는 사용자 인터페이스 라는 뜻으로, 웹 페이지에서 사용자와 상호작용하는 요소를 말합니다.
이 요소들의 사용성을 높이기 위해 기능을 추가하기도 하고 , 특별한 형태나 색상 등의 
스타일을적용하기도 하니다. 기능 구현에 앞서 ui를 먼저 구현한다고 함은 쉬게 말해
이들 요소의 외야을 먼저 만든다고 이해하면 됩니다.


viewer 컴포넌트 만들기
현재의 카운트를 표시하는 viewer 컴포넌트를 만들겠습니다.
Viewer.js
=====================================================================================
const Viewer = () => {
  return (
    <div>
      <div>현재 카운트 : </div>
      <h1>0</h1>
    </div>
  );
}

export default Viewer;
=====================================================================================

controller 컴포넌트 만들기

controller.js
=====================================================================================
const Controller = () => {
  return (
    <div>
        <button>-1</button>
        <button>-10</button>
        <button>-100</button>
        <button>+100</button>
        <button>+10</button>
        <button>+1</button>
    </div>
  );
}

export default Controller;
=====================================================================================

기능 구현하기 
UI 구현을 모두 마쳤으므로 이 UI 요소들을 움직이게 하는 카운터 기능들을 차례대로 구현하겠습니다.

state를 이용해 카운터 기능 구현하기
여러분이 구현할 카운터의 기능을 한 문장으로 정의하면 다음과 같습니다.
controller 컴포넌트에 있는 버튼을 클릭하면, viewer 컴포넌트에 있는 카운트가 증가하거나 감소해야 한다.
예를 들어 controller 컴포넌트에 있는 +100 버튼을 클릭하면 viewer 컴포넌트의 숫자는 0에서 100으로 바뀌어야합니다.

버튼 클릭 이벤트가 발생했을 때 컴포넌트 값을 동적으로 렌더링하려면 리액트의 state를 사용해야합니다.
그렇다면 카운터 앱에서 state를 사용해 어떻게 컴포넌트의 값을 동적으로 렌더링하는지 
그 과정을 설명해 보겠습니다.

먼저 카운트를 관리할 state를 만들고 초깃값을 0으로 설정합니다.
다음으로 controller 컴포넌트의 버튼을 클릭하면 현재 state 값을 버튼이 전달하는 값과 계산해 변경합니다.
다음으로 변경된 state 값은 viewer 컴포넌트에 전달되어 페이지의 카운트값을 업데이트합니다.

다음 과정에서 중요한 점을 하나 짚어보고 가겠습니다.
앱을 설계하는 데 꼭 필요한 사고 실험 같은 겁니다.

state는 어떤 컴포넌트에 만들까?
state는 반드시 컴포넌트 함수 안에 만들어야 합니다.
현재 여러분과 함께 만들고 있는 카운터 앱에는 app, viewer, controller 3개의 컴포넌트가 있습니다.
그렇다면 어떤 컴포넌트에서 카운터 앱의 state를 만들어야 할까요?
정답은 app 컴포넌트입니다.
왜 그럴까여? 정답인 이유를 확실히 아는 좋은 방법은 오답을 선택해 보고 무엇이 문제인지 직접 느껴보는 겁니다.
viewer 또는 controller 컴포넌트에 state를 만들고 이 state를 이용해 카운트 기능을 구현하면 어떤 문제가
생기는지 알아보겠습니다.

오답 1: viewer컴포넌트
Viewer.js
=====================================================================================
const Viewer = () => {
  const [count, setCount] = useState();
  return (
    <div>
      <div>현재 카운트 : </div>
      <h1>{count}</h1>
    </div>
  );
}

export default Viewer;
=====================================================================================
viewer 컴포넌트에서 state를 만들고 값을 랜더링하였습니다.
이제 controller 컴포넌트에서 버튼을 클릭하면 setCount를 클릭해야합니다.
여기서 문제가 발생합니다.

viewer컴포넌트가 controller 컴포넌트에 setCount를 전달할 방법이 없다는 겁니다.
앞서 살펴보았듯이 리액트에서 컴포넌트가 다른 컴포넌트에 데이터를 전달할 때는 Props를 사용하는데,
Props는 부모만이 자식에게 전달할 수 있습니다.
viewer와 controller 컴포넌트는 부모 자식 관계가 아니므로 어떠한 값도 전달할 수 없습니다.

오답 2: controller컴포넌트
이번에는 controller 컴포넌트에서 state를 만듭니다.
controller.js
=====================================================================================
import { useState } from "react";

const Controller = () => {
  const [count, setCount] = useState();
  const handlesSetCount = (value) => {
    setCount(count + value);
  };
  return (
    <div>
        <button onClick={() => handlesSetCount(-1)}>-1</button>
        <button onClick={() => handlesSetCount(-1)}>-10</button>
        <button>-100</button>
        <button>+100</button>
        <button>+10</button>
        <button>+1</button>
    </div>
  );
}

export default Controller;
=====================================================================================

버튼을 클릭하면 state는 기존 값에서 해당 버튼의 숫자와 계산한 값으로 변경됩니다.
그러나 여기서도 문제가 있습니다.
변경된 State값을 viewer 컴포넌트에 전달할 방법이 없기 때문입니다.
다시 말해 state 변수 count를 viewer 컴포넌트에 전달해야 하는데, viewer, controller 컴포넌트는
부모 자식 관계가 아니므로 그렇게 할 수 없습니다.

정답 : app 컴포넌트
viewer, controller 모두 카운터 앱의 state가 있을 컴포넌트가 아니라는 것을 확인했습니다.
이번에는 정답인 app 컴포넌트에서 state를 만들고 카운트 기능을 완성하겠습니다.

App.js
=====================================================================================
import './App.css';
import Viewer from './component/Viewer';
import Controller from './component/Controller';
import { useState } from 'react';

const App = () => {
  const [count, setCount] = useStae();
  const handleSetCount = (value) => {
    setCount(value + count);
  }

  return (
    <div>
      <h1>Simple Counter</h1>
      <section>
        <Viewer count={count} />     // (1)
      </section>
      <section>
        <Controller handleSetCount={handleSetCount} />  // (2)
      </section>
    </div>
  );
}

export default App;
=====================================================================================
(1)
viewer 컴포넌트에 state 변수 count의 값을 props로 전달합니다.
(2)
controller 컴포넌트에 state값을 변경하는 함수 setCount를 props로 전달합니다.

Viewer.js
=====================================================================================
const Viewer = ({ count }) => {
  return (
    <div>
      <div>현재 카운트 : </div>
      <h1>{count}</h1>
    </div>
  );
}

export default Viewer;
=====================================================================================
app 컴포넌트에서 받은 props를 페이지에 렌더링합니다.
리엑트에서는 부모가 리렌더 되거나 전달된 props가 변경되면 자식 컴포넌트도 자동으로 리랜더됩니다.
따라서 viewer 컴포넌트 props로 받은 state 값이 변경될 때 마다 리렌더되어 실시간으로 이 값을 
페이지에 렌더링합니다.

controller.js
=====================================================================================
const Controller = ({ handleSetCount }) => {
  return (
    <div>
        <button onClick={() => handleSetCount(-1)}>-1</button>
        <button onClick={() => handleSetCount(-10)}>-10</button>
        <button onClick={() => handleSetCount(-100)}>-100</button>
        <button onClick={() => handleSetCount(100)}>+100</button>
        <button onClick={() => handleSetCount(10)}>+10</button>
        <button onClick={() => handleSetCount(1)}>+1</button>
    </div>
  );
}

export default Controller;
=====================================================================================

지금까지 카운트 기능을 구현하려면 state를 app 컴포넌트에서 만들어야 한다는 점을 알아봤다.
그 이유를 다시 정리하면 state값은 viewer 컴포넌트, set 함수는 controller 컴포넌트에 전달해야하기 때문이다.
리액트는 state값이나 set 함수를 여러 컴포넌트에서 사용하는 경우 이들을 상위 컴포넌트에서 괸리합니다.
리액트에서는 이 기능을 다른 말로 state 끌어올리기(state lifting)이라고 합니다.

리액트답게 설계하기
리액트는 규모가 크고 빠른 웹 애플리케이션을 만들기 좋은 기술입니다.
이를 위해 리액트가 권장하는 애플리케이션 설계 방식에 대해 살펴보겠습니다.

리액트에서 컴포넌트 간에 데이터를 전달할 때는 props를 사용하는데,
전달 방향은 언제나 부모로부터 자식에게 전달하는 방식입니다.
리액트의 이러한 데이터 전달 특징을 단방향 데이터 흐름이라고 합니다.

데이터를 항상 아래로 전달하는 단방향 데이터 흐름은 모든 자동차가 같은 방향으로만 달리는 일방통행 차선을 연상하게 합니다.
모든 자동차가 한 방향으로만 달린다면, 초보 운전자 입장에서는 운전하기가 수월하며, 교통 상황도 한눈에 확인할 수 있어 편합니다. 리액트의 단방향 데이터 전달은 데이터의 이러한 흐름을 쉽게 이해할 수 있어, 관리하기에 좋습니다.
반면 state를 변경하는 이벤트는 자식에서 부모를 향해 역방향으로 전달되어야합니다.



리액트 컴포넌트의 라이프 사이클 -=-=-=-=-=-=-=-=-===
사람의 인생처럼 리액트 컴포넌트도 태어나고 사라지는 생애주기가 있습니다.
이를 다른 말로 라이프 사이클이라고 합니다. 리액트 컴포넌트의 라이프 사이클은 크게 3단계로 구분합니다.

Mount(탄생) => update(업데이트) => unmount(죽음)
페이지에 나타남   state 업데이트      페이지에서 제거됨
              props 업데이트
              부모 컴포넌트 리렌더

리액트 컴포넌트의 라이프 사이클은 크게 
마운트, 업데이트, 언마운트로 구분합니다.

마운트(mount) : 컴포넌트를 페이지에 처음 렌더링할 때
업데이트(update) : state나 props의 값이 바뀌거나 부모 컴포넌트가 리렌더해 자신도 리렌더될 때
언마운트(unmount): 더이상 페이지에 컴포넌트를 렌더링하지 않은 때

라이프 사이클을 이용하면 컴포넌트가 처음 렌더링될 때 특정 동작을 하도록 만들거나,
업데이트할 때 적절한지 적절한지 검사하거나, 페이지에서 사라질 때 메모리를 정리하는 등
여러 유용한 작업을 단계에 맞게 할 수 있습니다.
이를 라이프 사이클 제어라고 합니다.
리액트 훅의 하나인 함수 useEffect를 이용하면 이 사이클을 쉽게 제어할 수 있습니다.

useEffect
함수 useEffect는 어떤 값이 변경될 때마다 특정 코드를 실행하는 리액트 훅입니다.
이를 특정 값을 검사한다라고 표현합니다.
예컨데 useEffect를 이용하면 컴포넌트의 state값이 바뀔 때 마다 변경된 값을 콘설에 출력하게 할 수 있습니다.

App.js
=====================================================================================
import './App.css';
import Viewer from './component/Viewer';
import Controller from './component/Controller';
import { useEffect, useState } from 'react';

function App() {
  const [count, setCount] = useState(0);
  const handleSetCount = (value) => {
    setCount(value + count);
  }
  useEffect(() => {  //(1)
    console.log('count 업데이트 : ', count);
  }, [count]);
  return (
    <div className="App">
      <h1>Simple Counter</h1>
      <section>
        <Viewer count={count} />
      </section>
      <section>
        <Controller handleSetCount={handleSetCount} />
      </section>
    </div>
  );
}

export default App;
=====================================================================================
(1)
useEffect를 호출하고 두 개의 인수를 전달합니다.
첫 번째 인수로 콜백 함수를, 두 번째 인수로 배열을 전달합니다.

useEffect 용법
useEffect(callback, [deps])
callback : 콜백함수
[dpes] : 외존성배열

두 번째 인수로 전달한 배열을 의존성 배열(dependency Array)이라고 하는데,
useEffect는 이 배열 요소의 값이 변경되면 첫 번째 인수로 전달한 콜백함수를 실행합니다.
코드에서 useEffect의 의존성 배열에 state 변수 count가 있으므로, 이 값이 바뀌면 콜백함수가 실행됩니다.

count 업데이트 : 0
화면을 새로고침하면 count 업데이트 : 0이 콘솔에 출력됩니다.
아직 state 값을 변경한 적이 없음에도 콘솔에서 문자열을 출력한 이유는 state값을 초기화할 때도 useEffect가 이 변화를 감지하기 때문이다.

버튼을 클릭할 때마다 useEffect에 인수로 전달한 콜백 함수가 실행되며, 변경된 state 값을 콘솔에 출력합니다.
이렇듯 useEffect를 이용하면 특정 값이 바뀔 때마다 여러분이 원하는 코드를 실행하도록 만들 수 있습니다.


여러 개의 값 검사하기
useEffect의 의존성 배열 요소가 여러 개 있어도 마찬가지입니다.
즉, 배열 요소 중 하나가 변경되어도 useEffect는 콜백 함수를 실행합니다.
현재 카운터 앱의 App 컴포넌트에는 state 변수 count외에는 변경할 수 있는 값이 없습니다.
따라서 임시로 입력 촘을 추가하고, 이 폼에 입력한 데이터를 처리하는 text라는 이름의 state 변수를 하나 더 만들겠습니다.

이제 state변수 text의 값이 바뀌어도 콜백 함수를 실행할 겁니다.
저장하고 새로 만든 텍스트 입력 폼에서 hi라는 문자열을 입력합니다.

useEffect로 라이프 사이클 제어하기
이번에는 useEffect로 컴포넌트 라이프 사이클을 어떻게 제어하는지 살펴보겠습니다.
컴포넌트의 3단계 라이프 사이클 중 업데이트가 발생하면 특정 코드를 실행하겠습니다.



App.js
=====================================================================================
import './App.css';
import Viewer from './component/Viewer';
import Controller from './component/Controller';
import { useEffect, useState } from 'react';

function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  const handleSetCount = (value) => {
    setCount(value + count);
  }
  const handleChangeText = (e) => {
    setText(e.target.value);
  }
  useEffect(() => {   // (1)
    console.log('업데이트');
  })
  return (
    <div className="App">
      <h1>Simple Counter</h1>
      <section>
        <input value={text} onChange={handleChangeText} />
      </section>
      <section>
        <Viewer count={count} />
      </section>
      <section>
        <Controller handleSetCount={handleSetCount} />
      </section>
    </div>
  );
}

export default App;

=====================================================================================
(1)
앞서 작성했던 함수 useEffect 코드는 삭제하고 새롭게 useEffect를 생성합니다.
이때 두 번재 인수인 의존성 배열에는 아무것도 전달하지 않습니다.


두 번째 요소인 의존성 배열에 아무것도 전달하지 않으면, useEffect는 컴포넌트를 렌더링 할때마다 콜백 함수를 실행합니다. 세 번에 걸친 문자열 출력은 처음 페이지에 렌더링하는 마운트 시점 한 번과 컴포넌트를 리렌더하는 업데이트 시점 두 번의 결과입니다.
이번에는 useEffect에서 마운트 시점은 제외하고 업데이트 시점에만 콜백함수를 실행하겠습니다.
즉, 페이지에 처음 렌더링할떄는 콜백 함수를 실행하지 않고 리렌더될 때만 실행하겠다는 뜻입니다. 이를 위해 useRef도 이용합니다.


App.js
=====================================================================================
import './App.css';
import Viewer from './component/Viewer';
import Controller from './component/Controller';
import { useEffect, useState, useRef } from 'react';

function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  const didMountRef = useRef(false);   // (1)

  const handleSetCount = (value) => {
    setCount(value + count);
  }
  const handleChangeText = (e) => {
    setText(e.target.value);
  }
  useEffect(() => {   // (2)
    if(!didMountRef.current) {
      didMountRef.current = true;
      return;
    } else {
      console.log('업데이트');
    }
  })
  return (
    <div className="App">
      <h1>Simple Counter</h1>
      <section>
        <input value={text} onChange={handleChangeText} />
      </section>
      <section>
        <Viewer count={count} />
      </section>
      <section>
        <Controller handleSetCount={handleSetCount} />
      </section>
    </div>
  );
}

export default App;

=====================================================================================
(1)
현재 App 컴포넌트를 페이지에 마운트했는지 판단하는 변수 didMountRef를 Ref 객체로 생성합니다.
초기값으로 false를 설정합니다. Ref 객체는 돔 요소를 참조하는 것뿐만 아니라 컴포넌트의 변수로도 자주 활용됩니다.
(2)
컴포넌트 마운트 시점에는 콘솔에 컴포넌트 업데이트 문자열을 출력하지 않도록 조건문을 추가합니다.


useEffect의 콜백함수에 조건문을 추가했습니다. 이 코드를 좀 더 자세히 살펴보겠습니다.

useEffect(() => {    //   (1)
  if(!didMountRef.current) {    //   (2)
    didMountRef.current = true;
    return;
  } else {    //  (3)
    console.log('컴포넌트 업데이트');
  }
});
----------------------------------------------------------------------
(1)
의존성 배열로 아무것도 전달하지 않았으므로,  콜백함수는 마운트 시점에도 실행되어야 합니다.
(2)
조건문에서 didMountRef의 값을 검사합니다.
이 변수는 컴포넌트가 마운트했는지를 판단 할 때 사용하는데, 초깃값으로 false를 설정합니다.
따라서 콜백 함수를 처음 렌더링하는 마운트시점에는 조건식이 참(!false=true)이 되어 if문을 수행합니다.
if 문에서는 변수 didMountRef의 값을 true로 바꾸고(마운트가 됐음을 표시), return 문으로 함수를 종료합니다.
(3)
변수 didMountRef의 값이 false가 아니라면 콜백 함수의 호출은 마운트 시점이 아닙니다.

정리하자면 useEffect에서 의존성 배열을 인수로 전달하지 않으면 마운트, 업데이트 시점 모두 콜백 함수를 호출합니다.
그러나 코드처럼 콜백함수 내부에서 조건문과 Ref 객체로 특정 시점에만 코드를 실행하게 만들 수 있습니다.
즉, 마운트 시점에 호출하면 아궛도 호출하지 않고 함수를 종료하고, 업데이트 시점에 호출하면 문자열을 콘솔에 출력합니다.


컴포넌트의 마운트 제어하기---=-=-=-=-=-=-=--==--==-=-=--==--=-=-==-=--=-=-=
이번에는 컴포넌트의 마운트 시점에 실행되는 코드를 작성하겠습니다.
이를 컴포넌트의 마운트를 제어한다라고 합니다.

App.js
=====================================================================================
import './App.css';
import Viewer from './component/Viewer';
import Controller from './component/Controller';
import { useEffect, useState, useRef } from 'react';

function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  const didMountRef = useRef(false);   // (1)

  const handleSetCount = (value) => {
    setCount(value + count);
  }
  const handleChangeText = (e) => {
    setText(e.target.value);
  }
  useEffect(() => {   // (2)
    if(!didMountRef.current) {
      didMountRef.current = true;
      return;
    } else {
      console.log('업데이트');
    }
  })

  useEffect(() => {    //  (1)
    console.log('컴포넌트 마운트'); 
  }, [])

  return (
    <div className="App">
      <h1>Simple Counter</h1>
      <section>
        <input value={text} onChange={handleChangeText} />
      </section>
      <section>
        <Viewer count={count} />
      </section>
      <section>
        <Controller handleSetCount={handleSetCount} />
      </section>
    </div>
  );
}

export default App;

=====================================================================================
(1)
  useEffect(() => {    //  (1)
    console.log('컴포넌트 마운트'); 
  }, [])
  
함수 useEffect를 하나 더 만들고 의존성 배열에는 빈 배열을 전달합니다.
useEffect에서 빈 배열을 전달하면 컴포넌트의 마운트 시점에만 콜백 함수를 실행합니다.


컴포넌트 언마운트 제어하기-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
라이프 사이클의 마지막 단계인 언마운트는 컴포넌트가 페이지에서 제거될 때 입니다.
컴포넌트 언마운트 시점에 필요한 코드 실행 방법을 살펴보겠습니다.

클린업 ---=-=-=--=-=-=-=--=-=
리액트 컴포넌트의 언마운트 시점을 제어하기 위해서는 먼저 클린업 기능을 이해해야 합니다.
클린업이란 원래 청소라는 뜻입니다.
프로그래밍에서 이 개념은 특정 함수가 실행되고 종료된 후에, 미처 정리하지 못한 사항을 처리하는 일입니다.
개념은 몰라도 됩니다. 실습하면서 언제 클린업 개념이 필요한지 정도만 이해해도 충분합니다.

App.js
=====================================================================================
import './App.css';
import Viewer from './component/Viewer';
import Controller from './component/Controller';
import { useEffect, useState, useRef } from 'react';

function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  const didMountRef = useRef(false);   

  const handleSetCount = (value) => {
    setCount(value + count);
  }
  const handleChangeText = (e) => {
    setText(e.target.value);
  }
  useEffect(() => { 
    if(!didMountRef.current) {
      didMountRef.current = true;
      return;
    } else {
      console.log('컴포넌트 업데이트');
    }
  })

  useEffect(() => {   
    console.log('컴포넌트 마운트'); 
  }, [])

  useEffect(() => {  //   (1)
    setInterval(() => {   //  (2)
      console.log('깜박');
    }, 1000);
  });

  return (
    <div className="App">
      <h1>Simple Counter</h1>
      <section>
        <input value={text} onChange={handleChangeText} />
      </section>
      <section>
        <Viewer count={count} />
      </section>
      <section>
        <Controller handleSetCount={handleSetCount} />
      </section>
    </div>
  );
}

export default App;
=====================================================================================
(1)
useEffect를 호출하고 의존성 배열은 전달하지 않습니다.
따라서 App 컴포넌트를 렌더링할 때마다 첫 번째 인수로 전달한 콜백 함수가 실행된다.
(2)
useEffect의 콜백함수는 다시 함수 setInterval을 호출합니다.
setInterval은 자바스크립트 내장 함수로 두 번째 인수인 밀리초 시간이 경과하면 첫 번째 인수로 전달한 콜백함수를 실행합니다.
즉 인터벌(시간간격)을 설정하는 함수입니다. 결과적으로 1초마다 콘솔에 문자열 깜빡을 출력합니다.

패이지에서 +-버튼을 빠른 속도로 연속클릭합니다.
빠르게 연속 클릭해 state값을 변경하면 app 컴포넌트 여러 번 리렌더 됩니다.
그런데 setInterval에서 정한 인터벌이 아닌 매우 빠른 속도로 깜박 문자열이 콘솔에 출력되는 현상을 볼 수 있습니다.

분명 1초마다 문자열을 콘솔에 출력하도록 인터벌을 정했는데, 값자기 빠르게 출력되는 이유가 무엇일까요?
두 가지 이유가 복합적으로 얽혀 있기 때문입니다.

1. 하나는 App 컴포넌트를 렌더링할 때마다 useEffect의 콜백함수는 새로운 setInterval 함수를 만들고 새 인터벌을 생성한다는 점입니다.
useEffect의 두 번째 인수롤 아무것도 전달하지 않았기 때문에, 버튼을 클릭해 state를 변경하면 새 인터벌 함수를 생성합니다.
2. 또 하나는 함수 setInterval에서 인터벌을 생성한 다음에 이를 종료하지 않았기 때문입니다.
인터벌을 종료하는 clearinterval이라는 또 다른 내장 함수를 호출하지 않으면 문자열 출력은 멈추지 않습니다.

버튼을 클릭해 state값을 업데이트히먄 app 컴포넌트가 리렌더될 때마다 새로운 인터벌이 생성됩니다.
그러나 기존 인터벌을 종료하지 않았기 때문에 여러 개의 인터벌이 중복으로 만들어져 출력 속도가 빨라지게 됩니다.
이럴 때 요긴하게 사용하는 기능이 바로 useEffect의 클린업 기능입니다. 
앞서 작성한 useEffect를 다음과 같이 수정합니다.

useEffect(() => {  
  setInterval(() => {   
    console.log('깜박');
  }, 1000);
});

이 코드를 아래와 같이 수정한다.

useEffect(() => {
  const intervalId = setInterval(() => {   // (1)
    console.log('깜빡');
  }, 1000);

  return () => {   //  (2)
    console.log('클린업');
    clearInterval(intervalId);    //   (3)
  };
});

(1)
함수 setInterval은 새 인터벌을 생성하면 인터벌 식별자를(id)를 반환합니다.
이 id를 변수 intervalId에 저장합니다.
(2)
useEffect에 인수로 전달한 콜백 함수가 새 함수를 반환하도록 합니다.
이 함수는 클린업 함수로서 useEffect의 콜백함수가 실행되기 전이나 컴포넌트가 언마운트하는 시점에 실행됩니다.
(3)
클린업 함수는 clearInterval을 호출합니다.
인수로 (1)에서 생성한 인터벌 식별자를 전달해 앞서 생성한 인터벌을 삭제합니다.


현재 카운터 앱은 페이지에 렌더링한 컴포넌트를 사라지게 하는 기능이 없기 때문에 언마운트를 제어할 수 없다.
따라서 카운터 앱에 컴포넌트를 하나 새롭게 만든다.
이 컴포넌트는 conut 값이 짝수면 특정 문자열을 페이지에 렌더링한다.
조건부 렌터링으로 구현한다.

다음에는 Even 컴포넌트에서 useEffect를 사용해 이 컴포넌트가 언마운트 될 때 콘솔에 특정 문자열을 출력하겠습니다.


====================================vvv========================vv======
New Project   ==============================v======

프로젝트 준비하기

요구사항 분석하기
최종 구현 페이지에서 보듯이 할 일 관리 앱에는 다음과 같은 기능이 있습니다.
1. 오늘의 날짜를 요일, 월, 일, 연도순으로 표시합니다.
2. 할 일(todo)을 작성하는 입력 폼이 있고, 추가 버튼을 클릭하면 할 일 아이템을 생성합니다.
3. 할 일 관리 앱은 생성한 아이템을 페이지 하단에 리스트로 표시하는데, 키워드 검색으로 원하는 할 일만 추출할 수 있습니다.
4. 리스트로 표시하는 낱낱의 할 일 아이템은 일을 마쳤는지 여부를 표시하는 체크박스, 아이템 이름, 등족날짜, 그리고 삭제 버튼으로 이우어져 있습니다.


요구 사항 문석에 맞게 페이지의 각 UI 요소를 역할에 따라 구분할 수 있도록 컴포넌트 단위로 나누겠습니다.
컴포넌트를 적절히 분할하는 일은 개인적으로 많은 연습이 필요한데,
UI 요소를 컴포넌트 단위로 생각하는 게 중요합니다.

Header 컴포넌트 : 오늘의 날짜를 표시 형식에 맞게 보여줍니다.
TodoEditor 컴포넌트 : 새로운 할 일 아이템을 등록합니다.
TodoList 컴포넌트 -> TodoItem 컴포넌트
TodoList 컴포넌트 : 검색어에 맞게 필터링된 할 일 리스트를 렌더링합니다.(만약 검색 폼이 공백이면 필터링하지 않습니다.)
TodoItem 컴포넌트 : 낱낱의 할 일 아이템에는 기본 정보 외에도 체크박스와 삭제 버튼이 있습니다.
체크박스를 클릭하면 할 일을 마쳤는지 여부가 토글되고, 삭제 버튼을 클릭하면 해당 아이템을 삭제합니다.

리액트 앱 만들기--------------------------------------------------------------------------------

UI 구현하기
프로젝트 준비를 모두 끝마쳤다면 UI를 구현하겠습니다. 
할 일 관리 앱의 UI구현은 페이지의 전체 레이아웃부터 먼저 만들고, 세부 요소는 순서에 따라 차근차근 만들 예정입니다.

페이지 레이아웃 만들기
App.css 
==========================================================================================
.App {
  max-width: 500px;  // (1)
  width: 100%;   // (2)
  margin: 0 auto;  // (3)
  box-sizing: border-box;   // (4)
  padding: 20px;   // (5)
  border: 1px solid gray;   // (6)
}
==========================================================================================
(1)
할 일 관리 앱 페이지의 최대 너비를 500px로 고정합니다.
(2)
페이지 너비를 브라우저의 100%로 설정합니다.
그러나 (1)에서 정한 규칙 때문에 500px 이상으로 페이지의 너비가 늘어나지 않습니다.
따라서 (1)(2) 규칙에 따라 할 일 관리 앱 페이지는 최대 500px의 너비를 갖습니다.
만약 브라우저의 너비가 500px 보다 작아지면 페이지는 브라우저의 너비가 됩니다.
(3)
여백을 위아래는 0, 좌우는 자동으로 설정합니다.
좌우 여백을 자동으로 설정하면, UI 요소를 브라우저 가운데에 배치하기 위해 여백이 자동으로 조절됩니다.
예를 들어 현재 브라우저의 너비가 700px이면 좌우로 100px의 여백이 자동으로 설정되면서 페이지 UI가 브라우저 정중앙에 
자리 잡습니다. 만약 브라우저의 너비가 500px 이하라면 좌우 여백은 자동으로 0이 됩니다.
(4)
box-sizing은 요소의 크기를 어떤 것을 기준으로 계산할지 정하는 속성합니다.
box-sizing 속성을 border-box로 설정해 내부 여백이 요소의 크기에 영향을 미치지 않도록 설정합니다.
(5)
내부 여백을 20px로 설정합니다.


UI 구현을 흔히 퍼블리싱 또는 UI 개발이라고 합니다.
UI개발은 데이터를 가공하고 상태를 관리하는 구현 기능과 더불어 프론트앤드 엔지니어의 기본 소양 중 하나입니다.
가볍게 여기지 말고 꾸준히 학습하면서 충분한 경험을 쌓는게 꼭 필요합니다.

기능 구현 준비하기========================================================================================================================

이제 컴포넌트의 기능을 구현합니다.
먼저 컴포넌트별로 어떤 기능을 구현해야 하는지 다시 살펴보겠습니다.

App 컴포넌트 : input에 입력한 값을 state변수로 관리(데이터 관리)
Header컴포넌트 : 오늘의 날짜 표시
TodoEditor 컴포넌트 : 새로운 할 일 아이템 생성
TodoList : 검색 필터링으로 필터링된 할일 아이템 렌더링
TodoItem : 할일 체크 표시, 버튼 누르면 아이템 삭제


구현할 컴포넌트의 기능을 잘 살펴보면, 주로 데이터를 추가(생성)하고, 조회하고, 수정하고,삭제하는 기능으로 이루어져 있음을 알 수 있습니다.
이렇듯 데이터를 다루는 4가지 기능, 즉 추가(create), 조회(read), 수정(update), 삭제(delete) 기능을 앞 글자만 따서  CRUD라고 합니다.
CRUD는 데이터 처리의 기본 기능으로, 웹 서비스라면 기본적으로 갖추고 있어야 합니다.

create: 할 일 아이템 생성
기초 데이터 설정하기
기능 구현에 앞서 curd의 대상인 할 일 아이템부터 생성해야 합니다.

App.js
=====================================================================================
import { useState } from 'react';
import './App.css';
import Header from './component/Header';
import TodoEditor from './component/TodoEditor';
import TodoList from './component/TodoList';

function App() {
  const [todo, setTodo] = useState([]);  //  (1)
  return (
    <div className="App">
      <Header />
      <TodoEditor />
      <TodoList />
    </div>
  );
}

export default App;
=====================================================================================
(1)
useState를 이용해 할 일 아이템의 상태를 관리할 state를 만듭니다.
함수 useState에서 인수로 빈 배열을 전달해 state변수 todo의 기본값을 빈 배열로 초기화합니다.

5장에서 살펴보았듯이 함수 useStae는 리액트 훅으로 react 라이브러리에서 불러옵니다.
리액트에서는 보통 리스트 형태의 데이터를 보관할 때 배열을 이용합니다.
state 변수 todo는 [할 일 관리] 앱에서 데이터를 저장하는 배열이면서 동시에 일종의 데이터베이스 역할을 수행합니다.
예를 들어 사용자가 새 할일 아이템을 만들면, 빈 배열이었던 todo 값은 아이템이 추가된 배열로 업데이트됩니다.
이는 수삭제, 수정 모두 동일합니다.

데이터 모델링하기-------=-=--=--=-=-=-==
자바스크립트에서는 보통 현실의 사물이나 개념을 표현할 때 객체를 사용합니다.
현실의 사물은 일반적으로 여러 속성을 동시에 가지고 있기 때문입니다.
예를 들어 저자를 객체로 표현하면 다음과 같습니다.

let author = {name : '이정환', gender: 'male'}

이렇게 현실의 사물이나 개념을 프로그래밍 언어의 객체와 같은 자료구조로 표현하는 행위를 데이터 모델링이라고 합니다.
그렇다면 데이터 모델링은 왜 하는 걸까요?
이유는 간단합니다. 할 일 관리 앱의 할 일처럼 현실 세계의 사물이나 개념을 프로그래밍언러로 표현하고 다뤄야 하기 때문입니다.

checkbox : isDone(boolean) 할일을 마쳤는지
할 일 : content(string) 어떤 할 일인지
만든 날짜 : createDate(string) 언제 만들어졌는지
고유 식별자 : id

할 일 관리 햅에서 만들 아이템의 요소를 세부적으로 나누어 표시하였습니다.
하나의 할 일 아이템에는 일의 완료 여부, 일의 종류, 생성 날짜 등 3가지 정보가 담겨져 있습니다.
세 요소는 각각 isDone, content, createDate라는 별도의 이름으로 구분합니다.

또한 할 일 아이템에는 페이지에 렌더링하지는 않지만, id라는 고유 식별자가 있습니다.
이는 데이터베이스를 다뤄 본 독자라면 금방 아실 겁니다.
모든 아이템에는 해당 아이템을 구별하기 위한 고유한 식별자가 필요하기 때문입니다.
고유 식별자가 없으면 특정 아이템을 삭제하거나 수정하는 등의 연산이 불가능합니다.

모델링한 정보를 토대로 할 일 아이템을 자바스크립트 객체로 만들면 다음과 같습니다.
{
  id : 0,     // (1)
  isDone : false,     // (2)
  content : '공부하기',     // (3)
  createDate : new Date().getTime(),     // (4)
}

(1)
id는 특정 아이템을 식별하는 고유한 값입니다.
간단하게는 0부터 시작해 아이템을 추가할 때마다 1씩 늘어나도록 id에 값을 부여할 수 있습니다.
(2)
isDone은 불리언 자료형으로 현재 상황에서 할 일이 완료되었는지 여부를 확인할 때 이용합니다.
(3)
content는 할 일이 무엇인지 알려주는 문자열입니다.
(4)
createDate는 할 일의 생성시간입니다.
new Date()로 date 객체를 만들고 getTime 메서드를 이용해 이 객체를 타임 스탬프값으로 변환합니다.
타임 스템프값으로 시간을 저장하면 보관할 데이터의 양이 대폭 줄어듭니다.


데이터 모델링을 하는 이유는 데이터를 어떻게 다룰지 생각하기 위함입니다.
모델링 과정이 잘못되면 작업 과정에서 큰 문제가 생길 수 있습니다.
문제가 발생하면 데이터를 관리하는 모든 과정을 수정하게 되는데, 아예 프로젝트를 
처음부터 다시 시작하는 상황도 발생합니다.
혼자 개발하는 프로젝트라면 시간을 더 쏟으면 괜찮겠지만, 여러 팀원과 협업하는 프로젝트라면 문제가 심각해집니다.
따라서 모델링은 반드시 데이터 관리 프로그램을 구현하기 전에 
노트나 메모장 등에 적어 보면서 코드를 작성해야 합니다.
많은 시간을 들여서라도 데이터 모델링의 완성도를 높이는게 프로젝트의 시간이나 비용을 줄이는 데 큰 도움이 됩니다.


목 데이터 설정하기====================================================================================
목(mock) 데이터란 모조품 데이터라는 뜻입니다. 
기능을 완벽히 구현하지 않은 상태에서 테스트를 목적으로 사용하는 데이터입니다.
임시 데이터라 표현하기도 합니다.

기능을 아직 개발하지 않아 데이터가 없는 상황일 때 목 데이터를 사용합니다.
임시 데이터 역할을 하는 목 데이터가 있다면, 데이터 관리 기능 개발이 한결 수월해집니다.

App.js에서 목 데이터를 다음과 같이 작성합니다.

App.js
=====================================================================================
import { useState } from 'react';
import './App.css';
import Header from './component/Header';
import TodoEditor from './component/TodoEditor';
import TodoList from './component/TodoList';


const mockTodo = [
  {
    id: 0,
    isDone: false,
    content: '공부하기',
    createDate: new Date().getTime()
  },
  {
    id: 1,
    isDone: false,
    content: '빨래 널기',
    createDate: new Date().getTime()
  },
  {
    id: 2,
    isDone: false,
    content: '노래 연습하기',
    createDate: new Date().getTime()
  },
]

function App() {
  const [todo, setTodo] = useState([]);
  return (
    <div className="App">
      <Header />
      <TodoEditor />
      <TodoList />
    </div>
  );
}

export default App;
=====================================================================================
아직 TodoList 컴포넌트에 목 데이터를 전달하지 않았기 때문에 데이터를 페이지에 렌더링하지는 않습니다.
따라서 지금은 리액트 개발자 도구를 이용해 데이터가 잘 설정되는지 확인해야 합니다.

create 할일 추가하기
목 데이터 설정까지 완료했다면 이제 기능 구현을 위한 준비 과정은 모두 마쳤습니다.
이번에는 crun의 첫 번째 기능인 create를 구현하겠습니다.

할일 관리 앱에서 할 일이 추가되는 과정을 도식화
1. 사용자가 새로운 할 일을 입력한다.
2. TodoEditor 컴포넌트에 있는 추가 버튼을 클릭한다.
3. TodoEditor 컴포넌트는 부모인 App에게 아이템 추가 이벤트가 발생했음을 알리고 사용자가 추가한 한 일 데이터를 전달한다.
4. App컴포넌트는 TodoEditor 컴포넌트에서 받은 데이터를 이용해 새 아이템이 추가된 배열을 만들고 state변수 todo 값을 업데이트한다.
5. TodoEditor 컴포넌트는 자연스러운 사용자 경험을 위해 할 일 입력 폼을 초기화합니다.

아이템 추가 함수 만들기
TodoEditor 컴포넌트에서 추가 버튼을 클릭하면 App에 사용자가 입력한 할일 데이터를 전달하고 
추가 이벤트가 발생했음을 알려야 합니다.
먼저 App 컴포넌트에서 새 할 일 아이템을 추가하는 함수 onCreate를 만듭니다.
App.js
=====================================================================================
import { useState } from 'react';
import './App.css';
import Header from './component/Header';
import TodoEditor from './component/TodoEditor';
import TodoList from './component/TodoList';


const mockTodo = [
  {
    id: 0,
    isDone: false,
    content: '공부하기',
    createDate: new Date().getTime()
  },
  {
    id: 1,
    isDone: false,
    content: '빨래 널기',
    createDate: new Date().getTime()
  },
  {
    id: 2,
    isDone: false,
    content: '노래 연습하기',
    createDate: new Date().getTime()
  },
]

function App() {
  const onCreate = (content) => {  //(1)
    const newItem = {
      id: 0,
      isDone: false,
      content,
      createDate: new Date().getTiem()
    }

    setTodo(newItem, ...todo);    //(2)
  }


  const [todo, setTodo] = useState([]);
  return (
    <div className="App">
      <Header />
      <TodoEditor />
      <TodoList />
    </div>
  );
}

export default App;
=====================================================================================
(1)
TodoEditor 컴포넌트에서 추가 버튼을 클릭하면 호출할 함수 onCreate를 만듭니다.
이 함수는 TodoEditor 컴포넌트에서 사용자가 작성한 할 일 데이터를 받아 매개변수 content에 저장합니다.
이 데이터를 토대로 새 할 일 아이템 객체를 만들어 newItem에 저장합니다.
(2)
배열의 스프레드 연산자를 활용해 newItem을 포함한 새 배열을 만들어 state변수 todo를 업데이트
이렇게 작성하면 새롭게 추가된 아이템은 항상 배열의 0번 요소가 됩니다.


그런데 지금의 함수 onCreate에는 한 가지 문제점이 있습니다.
모든 아이템은 고유한 id를 가저야 하는데, 새롭게 추가할 아이템의 id가 모두 0으로 고정되기 때문입니다.
그럼 아이템을 추가할 때마다 중복 id가 만들어져 문제가 발생합니다.
Ref객체를 사용하면 이 문제를 간단히 해결할 수 있습니다.
Ref객체는 앞에서 살펴본 적이 있는데, 리액트 훅인 함수 useRef로 생성합니다.
Ref 객체는 리액트에서 주로 돔을 조작할 때 사용하지만, 컴포넌트의 변수로도 자주 활용합니다.

다음과 같이 App.js에서 새로운 Ref객체를 생성합니다.

const idRef = useRef(3)

초깃값이 3인 Ref객체를 생성해 idRef에 저장합니다.
참고로 idRef의 초깃값을 3으로 설정한 이유는 앞서 작성한 목 데이터의 id가 0,1,2이기 때문입니다.
이제 다음과 같이 idRef를 이용해 아이템을 생성할 때마다 id가 1씩 늘어나도록 설정합니다.

const idRef = useRef(3);
const onCreate = (content) => {
  const newItem = {
    id: idRef.current,
    isDone: false,
    content,
    createDate: new Date().getTime()
  }
  setTodo(newItem, ...todo);
  idRef.current++;
}
App 컴포넌트에서 할 일 아이템을 생성하는 함수 onCreate를 모두 작성했습니다.
함수 onCreate는 사용자가 TodoEditor 컴포넌트에서 추가 버튼을 클릭해야 호출되기 때문에 
이 컴포넌트에 props로 전달해야 한다.
  return (
    <div className="App">
      <Header />
      <TodoEditor onCreate={onCreate} />
      <TodoList />
    </div>
  );


아이템 추가 함수 호출하기
사용자가 할 일 입력 폼에서 아이템을 입력하고 추가 버튼을 클릭한다.
그러면 TodoEditor 컴포넌트는 새 할 일을 생성하기 위해 App에서 props로 받은 함수 onCreate를 호출하고 현재 사용자가 작성한 할 일을 인수로 전달합니다.

함수 onCreate를 사용하기 위해 다음과 같이 TodoEditor 컴포넌트를 수정합니다.

TodoEditor.js
====================================================================================================
import './TodoEditor.css';

const TodoEditor = ({ onCreate }) => {
  return (
    <div className="TodoEditor">
      <h4> 새로운 Todo 작성하기</h4>
      <div className="editor-wrapper">
        <input placeholder="새로운 Todo..." />
        <button >추가</button>
      </div>
    </div>
  );
}

export default TodoEditor;
====================================================================================================
다음으로 TodoEditor 컴포넌트의 할 일 입력 폼에서 사용자가 입력하는 새 할 일 데이터를 저장할 state를 만듭니다.
====================================================================================================
import './TodoEditor.css';
import { useState } from 'react';

const TodoEditor = ({ onCreate }) => {
  const [content, setContent] = useStae('');    // (1)
  const onChangeContent = (e) => {              //  (2)
    setContent(e.target.value);
  }
  return (
    <div className="TodoEditor">
      <h4> 새로운 Todo 작성하기</h4>
      <div className="editor-wrapper">
        <input    //  (3)
          placeholder="새로운 Todo..." 
          value={content}
          onChange={onChangeContent}
          />
        <button >추가</button>
      </div>
    </div>
  );
}

export default TodoEditor;
====================================================================================================
(1)
사용자가 입력 폼에 입력한 데이터를 저장할 content state변수를 만든다.
(2)
입력 폼의 onChnage 이벤트 핸들러 onChangeContent를 만듭니다.
(3)
입력 폼의 value 속성으로 content값을 설정하고,이벤트 핸들러 onChangeContent를 설정합니다.

여기서 잠깐
TodoEditor에서 사용자가 할 일을 입력하고 <추가> 버튼을 클릭했을 때 전달되는 할 일 데이터는 리액트 컴포넌트 트리 구조에서
표현되는 데이터는 아닙니다.
컴포넌트 트리 구조에서 데이터를 전달한다는 의미는 여러 컴포넌트가 동시에 동일한 데이터를 이용한다는 뜻입니다.
따라서 변하는 값인 state는 부모에서 자식으로 props를 이용해서만 전달할 수 있습니다.
버튼을 클릭하는 이벤트가 발생했을 때 인수로 전달하는 데이터는 컴포넌트 트리 구조상의 데이터 전달이 아닙니다.
일종의 이벤트가 전달된다고 생각하면 됩니다.

다음으로 추가 버튼을 클릭하면, 함수 onCreate를 호출하는 버튼 클릭 이벤트 헨들러를 만듭니다.
====================================================================================================
import './TodoEditor.css';
import { useState } from 'react';

const TodoEditor = ({ onCreate }) => {
  const [content, setContent] = useStae('');   
  const onChangeContent = (e) => {    
    setContent(e.target.value);
  }
  const onSubmit = () => {   //(1)
    onCreate(content);
  }
  return (
    <div className="TodoEditor">
      <h4> 새로운 Todo 작성하기</h4>
      <div className="editor-wrapper">
        <input   
          placeholder="새로운 Todo..." 
          value={content}
          onChange={onChangeContent}
          />
        <button onClick={onSubmit} >추가</button>   // (2)
      </div>
    </div>
  );
}

export default TodoEditor;
====================================================================================================
(1)
추가 버튼에 대한 이벤트 헨들러 onSubmit을 생성합니다.
onCreate를 호출하고 인수로 content의 값을 전달합니다.

이제 새 할 일을 작성하고 추가 버튼을 클릭해, App 컴포넌트의 todo에 새 아이템이 잘 추가되는지 확인합니다.
아직 App 컴포넌트의 todo 값을 페이지에 렌더링하는 Read 기능은 개발하지 않았기 때문에 개발자 도구의 components 탭에서 직접 확인해야 합니다.

이렇게 할 일 관리 앱에서 새 아이템을 추가하는 create 기능을 만들었습니다.
새롭게 추가한 아이템은 App 컴포넌트의 todo 배열 맨 앞에 추가됩니다.
그 이유는 앞서 함수 onCreate를 만들 때 새로 추가할 아이템은 배열의 0번 인덱스에 위치하도록 만들었기 때문입니다.


=============================================================================
==================================================================
create 완성도 높이기======================
지금까지 만든 create 기능은 아이템을 잘 추가하고,
id도 잘 배정하지만 완성도를 높이기 위해서는 몇 가지 해야 할 작업이 있습니다.

1. 빈 입력 방지하기=======================================================
프로그램의 완성도를 높이기 위해 create 기능을 좀 더 개선하겠습니다.
처음 할 일은 빈 입력을 방지하는 일입니다.
빈 입력은 말뜻 그대로 아무것도 입력하지 않은 상태에서 추가 버튼을 누르는 행위입니다.

아무것도 입력하지 않은 상태로 아이템을 추가하는 것을 방지하기 위한 방법은 여럿 있습니다.
이 책에서는 웹 서비스들이 일반적으로 채택하고 있는 빈 입력란에 포커스를 주는 기능을 구현합니다.


==================================================================
=============================================================================
</body>
</html>
